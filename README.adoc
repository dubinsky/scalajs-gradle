= Gradle plugin for Scala.js
:toc:
:toclevels: 4
:toc: preamble
// INCLUDED ATTRIBUTES
:version-gradle: 8.13
:version-plugin: 0.6.0
:version-scala: 3.6.4
:version-scala2-minor: 2.13
:version-scala2: 2.13.16
:version-scala-parallel-collections: 1.2.0
:version-sbt-test-interface: 1.0
:version-scalajs: 1.18.2
:version-scalajs-dom: 2.8.0
:version-scalajs-env-jsdom-nodejs: 1.1.0
:version-node: 16.19.1
:version-junit: 4.13.2
:version-framework-junit4: 0.13.3
:version-framework-junit4-scalajs: 1.18.2
:version-framework-munit: 1.1.0
:version-framework-scalacheck: 1.18.1
:version-framework-scalatest: 3.2.19
:version-framework-specs2: 5.5.8
:version-framework-specs2-scala2: 4.20.9
:version-framework-utest: 0.8.5
:version-framework-zio-test: 2.1.16
// INCLUDED ATTRIBUTES

image::https://github.com/dubinsky/scalajs-gradle/actions/workflows/CI.yaml/badge.svg[]

== Summary

This is a `Gradle` plugin that supports:

- compiling, linking and running `Scala.js` code;
- testing it using `sbt`-compatible testing frameworks;
- testing plain Scala code (without Scala.js) using `sbt`-compatible testing frameworks.

If needed, plugin automatically:

- applies Gradle Scala plugin to the project it is applied to;
- adds Scala.js dependencies that were not added explicitly;
- configures Scala compiler for Scala.js;
- retrieves and installs `Node.js`;
- installs configured Node modules using `npm`.

Plugin integrates with:

- Gradle test task configuration;
- Gradle test filtering and tagging;
- Gradle test logging;
- Gradle test reporting;
- IntelliJ Idea test running;
- IntelliJ Idea test reporting.

Plugin works with:

- Gradle {version-gradle};
- Scala.js 1.x;
- Node.js 16.x.

Plugin itself is written in Scala 3.
Project that the plugin is _applied_ to can use Scala 3, 2.13 or 2.12.
Plugin is not compatible with other Gradle plugins that bring Scala 2.12 or earlier onto the _buildScript_ classpath.

Gradle build file snippets below use the `Groovy` syntax, not the `Kotlin` one.

== Motivation

I dislike untyped languages, so if I have to write Javascript,
I want to be able to do it in Scala;
thanks to https://www.scala-js.org[Scala.js], this is possible.

I http://dub.podval.org/2011/11/08/sbt-why.html[dislike]
https://www.scala-sbt.org[sbt] -
the https://www.scala-js.org/doc/project[official build tool] of Scala.js,
which uses
https://github.com/scala-js/scala-js/tree/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin[Scala.js sbt plugin];
I want to be able to use my preferred build tool - https://gradle.org[Gradle].

Existing Scala.js Gradle https://github.com/gtache/scalajs-gradle[plugin] by
https://github.com/gtache[gtache] seems to be no longer maintained.

Hence, this plugin.

Plugin supports running tests using `sbt`-compatible testing frameworks
in a way integrated with `Gradle` and `IntelliJ Idea` _with or without_ Scala.js:
for plain Scala projects, Scala.js support can be disabled.

Multiple test frameworks can be used in the same project at the same time
(supporting this probably is not a critical requirement,
but sbt does it, so I must too ;)).

For years, I used https://github.com/maiflai/gradle-scalatest[Gradle ScalaTest plugin]
to run my Scala Tests; thank you, https://github.com/maiflai[maiflai]!
Since my plugin integrates with Gradle - and through it, with IntelliJ Idea -
some of the issues that maiflai's plugin has my does not:
https://github.com/maiflai/gradle-scalatest/issues/67[Test events were not received],
https://github.com/maiflai/gradle-scalatest/issues/69[ASCII Control Characters Printed].

I never tried an alternative ScalaTest integration
https://github.com/helmethair-co/scalatest-junit-runner[scalatest-junit-runner],
and if you need `JUnit5` _that_ is probably the way to go,
since my plugin does not support `JUnit5`
(it does support `Scala.js` though :)).

== Applying to a Gradle Project

Plugin is https://plugins.gradle.org/plugin/org.podval.tools.scalajs[published]
on the Gradle Plugin Portal; to apply it to a Gradle project:

[source,groovy,subs="+attributes"]
----
plugins {
  id 'org.podval.tools.scalajs' version '{version-plugin}'
}
----

Plugin will automatically apply the `Scala` plugin to the project,
so there is no need to manually list `id 'scala'` in the `plugins` block -
but there is no harm in it either;
either way, it is the responsibility of the project using the plugin
to add a standard Scala library dependency that the Scala plugin requires.

Unless `Scala.js` support is disabled, plugin will run in Scala.js mode;
to disable Scala.js and use the plugin for testing plain Scala code with `sbt`-compatible testing frameworks,
put the following into the `gradle.properties` file of the project:

[source,properties]
----
org.podval.tools.scalajs.disabled=true
----

In addition, the _presence_ of the
https://github.com/maiflai/gradle-scalatest[Gradle ScalaTest plugin]'s
`mode` property also disables Scala.js:

[source,properties]
----
com.github.maiflai.gradle-scalatest.mode = ...
----
(The _value_ of the `mode` property is ignored.)
This way, this plugin can be used as a drop-in replacement for
the ScalaTest one ;)

== Dependencies

Plugin automatically adds certain dependencies to various Gradle configurations
if they are not configured explicitly;
one of those configurations is `scalajs` - configuration that plugin creates.
Table below lists what is added to what configuration.

Scala.js dependencies are added only if Scala.js is enabled;
if `scalajs-library` dependency is specified explicitly,
plugin uses the same version for all the Scala.js dependencies that it adds.

When Scala.js is enabled, artifact is suffixed with `_sjs1`;
for instance, `org.scalatest:scalatest_sjs1_3` instead of `org.scalatest:scalatest_3`.
For Scala 2.13, use `_2.13` artifacts instead of the `_3` ones; for Scala 2.12 - `_2.12`.
Same rules apply to the test framework dependencies listed in the <<test-frameworks>> section.

Unless you want to override a version of some dependency that the plugin adds,
the only dependencies you need to add to the project are
the Scala library and test framework(s) that you use.

[%autowidth]
|===
|Name |goup:artifact |Configuration |Notes

|Scala.js Compiler
|org.scala-js:scalajs-compiler
|scalaCompilerPlugins
|only for Scala 2

|Scala.js JUnit Compiler Plugin
|org.scala-js:scalajs-junit-test-plugin
|scalaCompilerPlugins
|only for Scala 2 and only if JUnit4 for Scala.js is used

|Scala.js Linker
|org.scala-js:scalajs-linker
|scalajs
|

|Scala.js Node.js Environment
|org.scala-js:scalajs-env-jsdom-nodejs
|scalajs
|

|Scala.js Test Adapter
|org.scala-js:scalajs-sbt-test-adapter
|scalajs
|

|Scala.js-compiled Scala Library
|org.scala-lang:scala3-library_sjs1
|implementation
|only for Scala 3

|Scala.js Library
|org.scala-js:scalajs-library
|implementation
|

|Scala.js-compiled DOM Library
|org.scala-js:scalajs-dom_sjs1
|implementation
|

|Scala.js Test Bridge
|org.scala-js:scalajs-test-bridge
|testImplementation
|

|SBT Test Interface
|org.scala-sbt:test-interface
|testImplementation
|only when Scala.js is disabled

|===

In the examples below, latest versions of all dependencies are used.

=== Scala 3 with Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala}'
final String scala2versionMinor = '{version-scala2-minor}'
final String scalaJsVersion     = '{version-scalajs}'

dependencies {
  scalajs "org.scala-js:scalajs-linker_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-sbt-test-adapter_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-env-jsdom-nodejs_$scala2versionMinor:{version-scalajs-env-jsdom-nodejs}"

  implementation "org.scala-lang:scala3-library_3:$scalaVersion"
  implementation "org.scala-lang:scala3-library_sjs1_3:$scalaVersion"
  implementation "org.scala-js:scalajs-library_$scala2versionMinor:$scalaJsVersion"
  implementation "org.scala-js:scalajs-dom_sjs1_3:{version-scalajs-dom}"

  testImplementation "org.scala-js:scalajs-test-bridge_$scala2versionMinor:$scalaJsVersion"

  // Test framework(s) you use:
  /* JUnit4.js */  testImplementation "org.scala-js:scalajs-junit-test-runtime_$scala2versionMinor:{version-framework-junit4-scalajs}"
  /* MUnit */      testImplementation 'org.scalameta:munit_sjs1_3:{version-framework-munit}'
  /* ScalaCheck */ testImplementation 'org.scalacheck:scalacheck_sjs1_3:{version-framework-scalacheck}'
  /* ScalaTest */  testImplementation 'org.scalatest:scalatest_sjs1_3:{version-framework-scalatest}'
  /* specs2 */     testImplementation 'org.specs2:specs2-core_sjs1_3:{version-framework-specs2}'
  /* uTest */      testImplementation 'com.lihaoyi:utest_sjs1_3:{version-framework-utest}'
}
----

=== Scala 3 without Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala}'

dependencies {
  implementation "org.scala-lang:scala3-library_3:$scalaVersion"

  testImplementation 'org.scala-sbt:test-interface:{version-sbt-test-interface}'

  // Test framework(s) you use:
  /* JUnit4 */     testImplementation "com.github.sbt:junit-interface:{version-framework-junit4}"
  /* MUnit */      testImplementation 'org.scalameta:munit_3:{version-framework-munit}'
  /* ScalaCheck */ testImplementation 'org.scalacheck:scalacheck_3:{version-framework-scalacheck}'
  /* ScalaTest */  testImplementation 'org.scalatest:scalatest_3:{version-framework-scalatest}'
  /* specs2 */     testImplementation 'org.specs2:specs2-core_3:{version-framework-specs2}'
  /* uTest */      testImplementation 'com.lihaoyi:utest_3:{version-framework-utest}'
  /* ZIO Test */   testImplementation 'dev.zio:zio-test-sbt_3:{version-framework-zio-test}'
}
----

=== Scala 2 with Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala2}'
final String scala2versionMinor = '{version-scala2-minor}'
final String scalaJsVersion     = '{version-scalajs}'

dependencies {
  scalajs "org.scala-js:scalajs-linker_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-sbt-test-adapter_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-env-jsdom-nodejs_$scala2versionMinor:{version-scalajs-env-jsdom-nodejs}"

  scalaCompilerPlugins "org.scala-js:scalajs-compiler_$scalaVersion:$scalaJsVersion"
  scalaCompilerPlugins "org.scala-js:scalajs-junit-test-plugin_$scalaVersion:$scalaJsVersion"

  implementation "org.scala-lang:scala-library:$scalaVersion"
  implementation "org.scala-js:scalajs-library_$scala2versionMinor:$scalaJsVersion"
  implementation "org.scala-js:scalajs-dom_sjs1_$scala2versionMinor:{version-scalajs-dom}"

  testImplementation "org.scala-js:scalajs-test-bridge_$scala2versionMinor:$scalaJsVersion"

  // Test framework(s) you use:
  /* JUnit4.js */  testImplementation "org.scala-js:scalajs-junit-test-runtime_$scala2versionMinor:{version-framework-junit4-scalajs}"
  /* MUnit */      testImplementation "org.scalameta:munit_sjs1_$scala2versionMinor:{version-framework-munit}"
  /* ScalaCheck */ testImplementation "org.scalacheck:scalacheck_sjs1_$scala2versionMinor:{version-framework-scalacheck}"
  /* ScalaTest */  testImplementation "org.scalatest:scalatest_sjs1_$scala2versionMinor:{version-framework-scalatest}"
  /* specs2 */     testImplementation "org.specs2:specs2-core_sjs1_$scala2versionMinor:{version-framework-specs2-scala2}"
  /* uTest */      testImplementation "com.lihaoyi:utest_sjs1_$scala2versionMinor:{version-framework-utest}"
}
----

=== Scala 2 without Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala2}'
final String scala2versionMinor = '{version-scala2-minor}'

dependencies {
  implementation "org.scala-lang:scala-library:$scalaVersion"

  testImplementation 'org.scala-sbt:test-interface:{version-sbt-test-interface}'

  // Test framework(s) you use:
  /* MUnit */      testImplementation "org.scalameta:munit_$scala2versionMinor:{version-framework-munit}"
  /* ScalaCheck */ testImplementation "org.scalacheck:scalacheck_$scala2versionMinor:{version-framework-scalacheck}"
  /* ScalaTest */  testImplementation "org.scalatest:scalatest_$scala2versionMinor:{version-framework-scalatest}"
  /* specs2 */     testImplementation "org.specs2:specs2-core_$scala2versionMinor:{version-framework-specs2-scala2}"
  /* uTest */      testImplementation "com.lihaoyi:utest_$scala2versionMinor:{version-framework-utest}"
  /* ZIO Test */   testImplementation "dev.zio:zio-test-sbt_$scala2versionMinor:{version-framework-zio-test}"
}
----

== Scala.js
Ths section applies only when Scala.js support is enabled.

=== Compiling
To support Scala.js, Scala compiler needs to be configured to produce both the `class` _and_ `sjsir` files.

==== Scala 3

If the project uses Scala 3, all it takes is to pass `-scalajs` option to the Scala compiler, since
Scala 3 compiler has Scala.js support built in:

[source,groovy]
----
tasks.withType(ScalaCompile) {
  scalaCompileOptions.with {
    additionalParameters = [ '-scalajs' ]
  }
}
----

Plugin automatically adds this option to the main and test Scala compilation tasks if it is not present.

==== Scala 2
If the project uses Scala 2, Scala.js compiler plugin dependency needs to be declared:

[source,groovy,subs="+attributes"]
----
dependencies {
  scalaCompilerPlugins "org.scala-js:scalajs-compiler_$scalaVersion:{version-scalajs}"
}
----

Plugin does this automatically unless a dependency on `scalajs-compiler` is declared explicitly.

If the project uses Scala 2 _and_ JUnit 4 for Scala.js, a JUnit Scala compiler plugin is needed:

[source,groovy,subs="+attributes"]
----
dependencies {
  scalaCompilerPlugins "org.scala-js:scalajs-junit-test-plugin_$scalaVersion:{version-scalajs}"
}
----

Plugin adds this automatically also.

To enable Scala compiler plugins, their classpaths need to be given to the compiler
via a `-Xplugin:` option. Examples of the Gradle build script code that do that abound:

[source,groovy]
----
tasks.withType(ScalaCompile) {
  scalaCompileOptions.additionalParameters = [
    '-Xplugin:' + configurations.scalaCompilerPlugin.asPath
  ]
}
----

Such code is _not needed_, since Gradle `Scala` plugin does this automatically.

=== Linking

For linking of the main code, plugin adds `link` task of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSLinkMainTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkMainTask];
all tasks of this type automatically depend on the `classes` task.

For linking of the test code, plugin adds `testLink` task of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSLinkTestTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkTestTask];
all tasks of this type automatically depend on the `testClasses` task.

Link tasks exposes a property `JSDirectory` that points to a directory
with the resulting JavaScript, so that it can be copied where needed.
For example:

[source,groovy]
----
link.doLast {
  project.sync {
    from link.JSDirectory
    into jsDirectory
  }
}
----

Link tasks have a number of properties that can be used to configure linking.
Configurable properties with their defaults are:

[source,groovy]
----
link {
  optimization     = 'Fast'          // one of: 'Fast', 'Full'
  moduleKind       = 'NoModule'      // one of: 'NoModule', 'ESModule', 'CommonJSModule'
  moduleSplitStyle = 'FewestModules' // one of: 'FewestModules', 'SmallestModules'
  prettyPrint      = false
}
----

Setting `optimization` to `Full` enables:

- `Semantics.optimized`;
- `checkIR`;
- Closure Compiler (unless `moduleKind` is set to `ESModule`).

For `ScalaJSLinkMainTask` tasks, a list of module initializers may also be configured:

[source,groovy]
----
moduleInitializers {
  main {
    className = '<fully qualified class name>'
    mainMethodName = 'main'
    mainMethodHasArgs = false
  }
}
----

Name of the module initializer ('main' in the example above) becomes the module id.

=== Running

Plugin adds `run` task for running the main code (if it is an application and not a library);
this task automatically depends on the `link` task.

Additional tasks of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSRunMainTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSRunMainTask]
can be added manually;
their dependency on a corresponding `ScalaJSLinkMainTask` task must be set manually too.

=== Node.js

For running `Scala.js` code and tests, plugin uses `Node.js`.

In Scala.js mode, plugin adds `node` extension to the project.
This extension can be used to specify the version of Node.js to use and Node modules to install:

[source,groovy,subs="+attributes"]
----
node {
  version = '{version-node}'
  modules = ['jsdom']
}
----

If Node.js version is not specified, plugin uses "ambient" Node.js -
the one installed on the machine where it is running.

If Node.js version is specified, plugin will install it (under `~/.gradle/nodejs`) and use it.

Scala.js does not support versions of Node.js newer than "{version-node}", so none of the "17.9.1", "18.15.0", "19.8.1".
I do not know anything about Node.js, and find this surprising - but I am sure there is a good
technical or political reason for this ;)

If no Node modules to install are listed, plugin installs the `jsdom` module,
which is required for `org.scala-js:scalajs-env-jsdom-nodejs`.

To get better traces, one can add `source-map-support` module.

Node modules for the project are installed in the `node_modules` directory in the project root.

If `package.json` file does not exist, plugin runs `npm init private`.

Plugin adds tasks `node` and `npm` for executing `node` and `npm` commands
using the same version of Node.js that is used by the plugin;
those tasks can be used from the command line like this:

[source,shell]
----
./gradlew npm --npm-arguments 'version'
./gradlew node --node-arguments '...'
----

== Testing

=== Test Task
Test task added by the plugin is derived from the normal Gradle `test` task,
and can be configured  in the traditional way - with some caveats:

- ScalaJS tests must be run in the same JVM where they are discovered,
so they are not forked;
- plugin applies its own Gradle test framework (`useSbt`) to each test task;
re-configuring the Gradle test framework (via `useJUnit`, `useTestNG` or `useJUnitPlatform`) is not supported;
- `isScanForTestClasses` must be at its default value `true`;
- test filtering support is detailed in <<test-filtering>>;
- test tagging support is detailed in <<test-tagging>>;
- dry run (`test.dryRun=true` or `--test-dry-run` command line option) is supported.

If there is a need to have test runs with different configurations,
more testing tasks can be added manually.

For plain Scala projects (no Scala.js), the type of the test task is
link:src/main/scala/org/podval/tools/scalajsplugin/jvm/JvmTestTask.scala[org.podval.tools.scalajsplugin.jvm.JvmTestTask].
Any such task will automatically depend on the `testClasses` task (and `testRuntimeClassPath`).

For Scala.js projects the type of the test task is
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSTestTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSTestTask].
Such test tasks have to depend on a
`org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkTestTask task`.
The `test` task added by the plugin does it automatically;
for manually added tasks this dependency has to be added manually.

[#test-frameworks]
=== Test Frameworks
Plugin replaces the `test` task with one that supports running
sbt-compatible test frameworks; multiple test frameworks can be used at the same time.

Currently, the following test frameworks are supported:

[%autowidth]
|===
| Name | group:artifact | Version | Notes

| JUnit4
| `com.github.sbt:junit-interface`
| {version-framework-junit4}
a|
- JVM only, no Scala.js
- Java dependency, no Scala version in the artifact

| JUnit4 for Scala.js
| `org.scala-js:scalajs-junit-test-runtime`
| {version-scalajs}
a|
- Scala.js only, no JVM
- Scala dependency, no `sjs1` suffix in the artifact

| MUnit
| `org.scalameta:munit`
| {version-framework-munit}
|

| ScalaCheck
| `org.scalacheck:scalacheck`
| {version-framework-scalacheck}
|

| ScalaTest
| `org.scalatest:scalatest`
| {version-framework-scalatest}
|

| Specs2
| `org.specs2:specs2-core`
| {version-framework-specs2}
a|
- latest version for Scala 2 is 4.20.9

| uTest
| `com.lihaoyi:utest`
| {version-framework-utest}
|

| ZIO Test
| `dev.zio:zio-test-sbt`
| {version-framework-zio-test}
|
|===

JUnit4 SBT interface (com.github.sbt:junit-interface)
is a separate project from JUnit4 itself;
SBT interface dependency brings in the underlying framework dependency
`junit:junit` transitively;
its version can be overridden in the Gradle build script.

JUnit4 for Scala.js is a framework distinct from JUnit4:
it is a partial translation/re-implementation of JUnit4 circa 2015
and has different capabilities.

MUnit uses JUnit internally, and brings in the underlying framework dependency transitively:
on JVM - `junit:junit`; on Scala.js - `org.scala-js:scalajs-junit-test-runtime`;
its version can be overridden in the Gradle build script.

ZIO Test is currently not supported on Scala.js because of a bug in ZIO Test
(https://github.com/dubinsky/scalajs-gradle/issues/37[issues/37]).

TestNG is not supported: its
https://github.com/sbt/sbt-testng[SBT interface] is long since abandoned.

JUnit5 is not supported, since it insists on using its own test discovery mechanism.
Both Gradle and IntelliJ Idea support JUnit5 out of the box,
and since there is no JUnit5 for Scala.js,
there is not much the plugin can add anyway.

[#test-filtering]
=== Test Filtering

Gradle uses three sets of patterns to filter tests by names;
two of them - `includeTestsMatching` and `excludeTestsMatching` -
are set in the Gradle build file:

[source, groovy]
----
test {
  filter {
    includeTestsMatching "org.podval.tools.test.JUnit4Test.success"
    includeTestsMatching "org.podval.tools.test.JUnit4Test.failure"
    excludeTestsMatching "ZioTestTest"
  }
}
----

The third one is set via a command-line option `--tests`.

Inclusion rules are:

- if both build file and the command line inclusions are specified,
  to be included, a test must match both.
- if no inclusions nor exclusions are specified, all tests are included.
- if only inclusions are specified, only tests matching one of them are included.
- if only exclusions are specified, only tests not matching any of them are included.
- if both inclusions and exclusions are specified, only tests matching one of the inclusions and not matching any of the exclusions are included.

Gradle inclusion/exclusion patterns can contain wildcards "*";
semantics of matching against those patterns is complicated,
sometimes surprising and difficult (for me) to understand;
that is why I followed Gradle implementation as closely as possible.
Plugin implements test _class_ inclusion/exclusion itself,
but individual test _case_ inclusion/exclusion is handled by the test framework used.

SBT test interface that the plugin uses to communicate with the test frameworks
has means of expressing that a test case with specific name is to be included
(https://github.com/sbt/test-interface/blob/master/src/main/java/sbt/testing/TestSelector.java[TestSelector])
and that test cases whose names contain a specific string are to be included
(https://github.com/sbt/test-interface/blob/master/src/main/java/sbt/testing/TestWildcardSelector.java[TestWildcardSelector]);
it does not have any means of expressing which test cases are to be excluded.

Plugin does not have access to the list of test case names
(which are framework-dependent),
so, even though I try to translate Gradle filtering to the SBT test interface filtering as close as possible, when test case filtering is involved,
this translation can in general case lose fidelity.
My immediate goal was to make sure the filtering scenarios that are used in practice
work as intended; turns out, infidelities in the implementation of test case filtering
in specific test frameworks make even that impossible in some cases,
as is detailed below.

The following patterns specify test classes to run:

- `"*"`: all tests, just as if no includes are specified;
- `"*IntegrationTest"`: classes whose named end with "IntegrationTest";
- `"Scala*"`: classes whose name starts with "Scala";
- `"org.podval.tools.test.Scala*"`: classes in specified package whose name starts with "Scala";
- `"org.podval.tools.test.*"`: tests in specified package (used by IntelliJ Idea, see <<intellij-idea-integration>>);
- `"org.podval.tools.test.ScalaTest"`: tests in specified class (used by IntelliJ Idea, see <<intellij-idea-integration>>).

All these patterns work as intended.

The following patterns specify test cases to run:

- `"org.podval.tools.test.JUnit4Test.success"`: specified test case in specified class (used by IntelliJ Idea, see <<intellij-idea-integration>>);
- `"org.podval.tools.test.JUnit4Test.succ*"`: test cases whose names start with "succ" in specified class.

With these patterns, what actually happens depends on the
fidelity with which test framework used implements
even the restricted test case selection means of the SBT test interface:

- `JUnit4`, `ScalaTest` and `MUnit` on JVM do the right thing;
- `JUnit4 for Scala.js`, `MUnit` on Scala.js and `uTest` do not support test case selectors and
  run all test cases in the class;
- `specs2` does the right thing when individual test case names are used
  but if test case wildcards are used it runs all test cases in the class;
- `ScalaCheck` 's test filtering functionality is not available:
  https://github.com/dubinsky/scalajs-gradle/issues/43[issue];
- `ZIO test` treats specific test case inclusions as wildcards
  and instead of running just the named test cases runs all whose names contain
  the specified string, because the only test case name-based filtering that ZIO Test supports is "search terms", which
  https://github.com/zio/zio/blob/series/2.x/test/shared/src/main/scala/zio/test/FilteredSpec.scala#L32[work as wildcards];
- `ZIO Test` in the presence of wildcard test case inclusions
  runs all tests in the class because of a https://github.com/dubinsky/scalajs-gradle/issues/45[bug].

[#test-tagging]
=== Test Tagging

Names of the tags to include and exclude in the run are specified in:

[source,groovy]
----
test {
  useSbt {
    includeCategories = ["itag1", "itag2"]
    excludeCategories = ["etag1", "etag2"]
  }
}
----

Inclusion rules are:

- if no inclusions nor exclusions are specified, all tests are included.
- if only inclusions are specified, only tests tagged with one of them are included.
- if only exclusions are specified, only tests not tagged with any of them are included.
- if both inclusions and exclusions are specified, only tests tagged with one of the inclusions and not tagged with any of the exclusions are included.

==== JUnit4
Tag tests with classes or traits
that do not have to be derived from anything JUnit-specific;
In the Gradle build file, `excludeCategories` and `includeCategories`
list fully-qualified names of tagging classes or traits.

[source, scala]
----
trait IncludedTest
trait ExcludedTest
@org.junit.experimental.categories.Category(Array(
  classOf[org.podval.tools.test.IncludedTest],
  classOf[org.podval.tools.test.ExcludedTest]
))
@Test def excluded(): Unit = ()
----

==== JUnit4 for Scala.js
Does not support test tagging.

==== MUnit
MUnit is based on JUnit4, so it supports the `Category`-based exclusion and inclusion;
since on Scala.js MUnit uses `JUnit4 for Scala.js`,
which does not support this mechanism,
MUnit does not support it either.

Plugin does not use `Category`-based mechanism;
MUnit provides a different, `Tag`-based mechanism,
and that is what plugin uses.

Tag tests with values that are instances of `munit.Tag`:

[source, scala]
----
val include = new munit.Tag("org.podval.tools.test.ExcludedTest")
val exclude = new munit.Tag("org.podval.tools.test.ExcludedTest")
test("excluded".tag(include).tag(exclude)) {}
----

When tagging classes used for inclusion/exclusion are not available,
MUnit crashes with a `ClassNotFound`.

==== ScalaCheck
ScalaCheck itself does not support test tagging,
but if it is used via another test framework -
like `ScalaTest` or `specs2` -
test tagging mechanisms provided by that framework can be used.

==== ScalaTest
Tag tests with objects that extend `org.scalatest.Tag`:

[source, scala]
----
object Include extends org.scalatest.Tag("org.podval.tools.test.IncludedTest")
object Exclude extends org.scalatest.Tag("org.podval.tools.test.ExcludedTest")
"excluded" should "not run" taggedAs(Include, Exclude) in {  true shouldBe false }
----

==== specs2
Tag tests with tag names:

[source,scala]
----
exclude tests tagged for exclusion $excludedTest ${tag(
  "org.podval.tools.test.IncludedTest",
  "org.podval.tools.test.ExcludedTest"
)}
----

==== uTest
Does not support test tagging.

==== ZIO Test
Tag tests with tag names using `TestAspect.tag`:

[source, scala]
----
test("excluded") { assertTrue(1 == 0) } @@ TestAspect.tag(
  "org.podval.tools.test.IncludedTest",
  "org.podval.tools.test.ExcludedTest"
)
----

=== Skipped Tests
When running some test methods explicitly included by a filter,
I do not want to see skipped methods mentioned in the test report
just as I do not want to see other skipped test classes there.

I do want to see tests explicitly ignored in code
(e.g., in ScalaTest, or JUnit4's falsified assumptions).

During a dry run, though, I want to see _everything_ that was skipped,
including test classes that were skipped entirely;
for such, a test case named `dry run` is reported as skipped.

[#intellij-idea-integration]
== IntelliJ Idea Integration

Whatever you can run from Idea you can also debug -
unless Scala.js is used:
Scala.js code runs on Node.js, so there is no debugging it - breakpoints have no effect.

As with any other Gradle project imported into Idea, you can run Gradle tasks.

IntelliJ lets you run objects with main methods using either:

- object node in the project tree or
- gutter icon in the object's file

When Scala.js is enabled, objects can not be run this way:
the code needs to be compiled for Scala.js, linked and run on Node.js.
This is what the `run` task added by the plugin is for.

As usual, when you run tests:

- results are displayed in tree form
- test counts are displayed.

As usual, you can run all tests from the project tree using any of the nodes:

[source]
----
<root>
  src
    test
      scala
----

As usual, you can run all tests from a package using the package's node in the project tree.
Idea supplies Gradle test filter "selected.package.*".

As usual, you can run individual test for _the frameworks Idea recognizes_ using either:

- test's node in the project tree or
- gutter icon in the test's file

Idea supplies Gradle test filter "fully.qualified.TestClass".

From the test frameworks this plugin supports,
Idea recognizes:

- JUnit4 (for some reason, tests can not be run from the project tree)
- JUnit4 for Scala.js
- MUnit

Scala plugin for Idea recognizes
(but does nor reflect the results of the previous run in the gutter icon of the test):

- ScalaTest
- Specs2
- uTest

Not recognized are:

- ScalaCheck
- ZIO Test

Since `ZIO Test` tests are  objects with main method,
they can be run from Idea (when not using Scala.js),
but there is no test result tree nor test counts displayed,
and since Gradle is not involved, no test reports.

For `JUnit4` and `JUnit4 for Scala.js`,
Idea also recognizes individual test methods within a test class;
they can be run using their gutter icons.
Idea supplies Gradle test filter "fully.qualified.TestClass.testMethod".

For `MUnit`, only the first test method gets a gutter icon,
but Idea supplies test filter "fully.qualified.TestClass",
so that icon runs the whole class, not the test method it is for.

For `ScalaTest`, every test method gets a gutter icon,
but Idea supplies test filter "fully.qualified.TestClass",
so that icon runs the whole class, not the test method it is for.

For `specs2` and `uTest`, there are no gutter icons for individual test methods.

== Notes and Credits

=== Scala.js Linking
It is reasonably easy - if repetitive - to configure the Scala compiler and add needed Scala.js dependencies by hand;
what really pushed me to build this plugin is the difficulty and ugliness involved in
manually setting up Scala.js linking in a Gradle build script.

A Stack Overflow https://stackoverflow.com/a/65777102/670095[answer]
by https://stackoverflow.com/users/1149944/gzm0[gzm0] was _extremely_ helpful
for understanding how the Scala.js linker should be called. Thanks!

I also looked at

- https://www.scala-js.org/doc/tutorial/basic[Scala.js Tutorial]
- https://github.com/scala-js/scala-js/tree/main/linker-interface[Scala.js Linker]
- https://github.com/scala-js/scala-js/tree/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin[Scala.js sbt plugin]
- https://github.com/gtache/scalajs-gradle[Old Scala.js Gradle plugin] by https://github.com/gtache[gtache]
- https://github.com/scala-js/scala-js-cli/tree/main/src/main/scala/org/scalajs/cli[Scala.js CLI]
- https://www.scala-lang.org/2020/11/03/scalajs-for-scala-3.html[Implementing Scala.JS Support for Scala 3]

=== Testing

Basic testing functionality was
https://github.com/dubinsky/scalajs-gradle/issues/7[requested]
by https://github.com/zstone1[zstone1] - thanks for the encouragement!

To figure out how `sbt` itself integrates with testing frameworks, I had to untangle some `sbt` code, including:

- `sbt.Defaults`
- `sbt.Tests`
- `sbt.TestRunner`
- `sbt.ForkTests`
- `org.scalajs.sbtplugin.ScalaJSPluginInternal`

Turns out, internals of `sbt` are a maze of twisted (code) passages,
all alike, where pieces of code are stored in key-value maps,
and addition of such maps is used as an override mechanism.
What a disaster!

There are _two_ testing interfaces in `org.scala-sbt:test-interface:1.0`;
I use the one used by the Scala.js sbt plugin - presumably the "new" one ;)

Just being able to run the tests with no integration with
Gradle or IntelliJ Idea seemed suboptimal,
so I decided to look into proper integrations of things like
`org.scala-js:scalajs-sbt-test-adapter` and
https://github.com/sbt/test-interface[org.scala-sbt:test-interface].

I perused code from:

- https://github.com/gradle/gradle[Gradle];
- https://github.com/JetBrains/intellij-community[IntelliJ Idea];
- https://github.com/maiflai/gradle-scalatest[Gradle ScalaTest plugin].

This took _by far_ the most of my time
(and takes up more than 3/4 of the plugin code),
and uncovered a number of surprises.

IntelliJ Idea instruments Gradle test task with its `IJTestEventLogger` -
but _only_ if the task is of type `org.gradle.api.tasks.testing.Test`,
so that is what I derive my test task from.

Once I worked out how to integrate tests on Scala.js with Gardle and IntelliJ Idea,
it was reasonably easy to re-use this integration to run tests
using sbt-compatible frameworks _without_ any Scala.js involved -
in plain Scala projects.

=== Testing on Scala.js

Scala.js tests must be run in the same JVM where their frameworks were instantiated
(see https://github.com/scala-js/scala-js/blob/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin/ScalaJSPluginInternal.scala#L676[org.scalajs.sbtplugin.ScalaJSPluginInternal]).
`TestExecuter` makes sure that the tests are not forked,
and `TestTask` overrides
`org.gradle.api.tasks.testing.Test.getMaxParallelForks()`
to return `1` on `Scala.js` to prevent `MaxNParallelTestClassProcessor`
from forking.

On JVM, exceptions are serialized in Gradle's `org.gradle.internal.serialize.ExceptionPlaceholder`, which contains lots of details;
on Scala.js, `org.scalajs.testing.common.Serializer.ThrowableSerializer`
turns them all into `org.scalajs.testing.common.Serializer$ThrowableSerializer$$anon$3`;
since source mapping is used only on Scala.js,
there is no point trying to preserve the original exception:
it is already lost;
so just wrap what remains in `TestExecutionException`.

=== Node.js

`Node.js` support that the plugin provides
is heavily inspired by (read: copied and reworked from :))
https://github.com/srs/gradle-node-plugin[gradle-node-plugin]
by https://github.com/srs[srs].

That plugin is not used directly because its tasks are not reusable
unless the plugin is applied to the project,
and I do not want to apply Node Gradle plugin to every project that uses my
Scala.js Gradle plugin.

Also, I want to be able to run `npm` from within my code without creating tasks.
Also, I would like to be able to use Node available via GraalVM's polyglot support.

My simplified Node support is under 300 lines.

=== Test Run Data
Test detection produces more information than just the class name:

- framework that recognized the test
- fingerprint
- selectors

I need to deliver this additional information to forked test processors.

For a while, I used modified serializer for this;
of course, serializer is hard-coded in the Gradle code,
so to use mine I had to modify three Gradle files...

I even made a https://github.com/gradle/gradle/pull/24088[pull request]
to add flexibility in this regard to Gradle -
but then I realized that I can encode additional information I need
to get to the worker in the test class name!

=== Test Events
Turns out that IntelliJ Idea integration only works when all the calls to
the IJ listener happen from the same thread
(it probably uses some thread-local variable to set up cross-process communications).
Since some of the calls are caused by the call-back from the sbt testing interface's
event handler, I get "Test events were not received" in the Idea test UI.
It would have been nice if this fact was documented somewhere :(
I coded an event queue with its own thread, but then discovered that:

- Gradle provides a mechanism that ensures that all the calls are made from the same thread: `Actor.createActor.getProxy`;
- when tests are forked, `MaxNParallelTestClassProcessor` is used, which already does that, so I do not need to;
- when running on `Scala.js` everything is single-threaded anyway.

=== Test Ids
`org.gradle.internal.remote.internal.hub.DefaultMethodArgsSerializer`
seems to make a decision which serializer registry to use based on the
outcome of the `SerializerRegistry.canSerialize()` call
for the class of the first parameter of a method;
test id is the first parameter of the `TestResultProcessor.output()`, `completed()` and `failure()` calls.
Without some tricks like registering a serializer for `AnyRef` and disambiguating
in the `SerializerRegistry.build()` call,
neither `null` nor `String` are going to work as ids.

This is _probably_ the reason why Gradle:

- makes all test ids `CompositeIdGenerator.CompositeId`
- registers a `Serializer[CompositeIdGenerator.CompositeId]` in `TestEventSerializer`.

Gradle just wants to attract attention to its `TestEventSerializer`, so it registers
serializers for the types of the first parameters of all methods - including the test ids ;)

And since the minimum of composed is two, Gradle uses test ids that are composite of two Longs.

AbstractTestTask installs `StateTrackingTestResultProcessor`
which keeps track of all tests that are executing in any `TestWorker`.
That means that test ids must be scoped per `TestWorker`.
Each `TestWorker` has an `idGenerator` which it uses to generate `WorkerTestClassProcessor.workerSuiteId`;
that same `idGenerator` can be used to generate sequential ids for the tests in the worker,
satisfying the uniqueness requirements - and resulting in the test ids always being
a composite of exactly two Longs!

Because tests are scoped by the workers, it does not seem possible to group test results by framework.

=== Test Output
Since I can not use the real `rootTestSuiteId` that `DefaultTestExecuter`
supplies to the `TestMainAction` - because it is a `String` -
and I am not keen on second-guessing what it is anyway,
I use a `idPlaceholder` in `WorkerTestClassProcessor`
and change it to the real one in `FixUpRootTestOutputTestResultProcessor`.

Gradle controls the formatting of the test output:

- indenting is hard-coded in the
https://github.com/gradle/gradle/blob/master/subprojects/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestEventLogger.java#L63[TestEventLogger.onOutput()];
- addition of the test name and the name of the output stream at the top of each indented batch
(output of the same test) is hard-coded in the
https://github.com/gradle/gradle/blob/master/subprojects/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/AbstractTestLogger.java#L51[AbstractTestLogger.logEvent()].

IntelliJ Idea, in `addTestListener.groovy`:

- https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/java/resources/org/jetbrains/plugins/gradle/java/addTestListener.groovy#L30[suppresses]
the output and error events and
- https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/java/resources/org/jetbrains/plugins/gradle/java/addTestListener.groovy#L29[adds]
its own test and output listener
https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/resources/org/jetbrains/plugins/gradle/IJTestLogger.groovy[IJTestEventLogger]
that does no batching, indenting or adding.

MUnit (but not JUnit4!) and uTest write to standard output/error
instead of logging via supplied sbt logger,
so their output does not go through my `TestClassProcessor.output()`;
do I need to modify capturing to get their output?

=== Testing the Tests
I coded a neat way to test the plugin itself and
various features of the various frameworks and their support by the plugin:
link:src/test/scala/org/podval/tools/test/testproject/Feature.scala[Feature],
link:src/test/scala/org/podval/tools/test/testproject/Fixture.scala[Fixture],
link:src/test/scala/org/podval/tools/test/testproject/ForClass.scala[ForClass],
link:src/test/scala/org/podval/tools/test/testproject/GroupingFunSpec.scala[GroupingFunSpec],
link:src/test/scala/org/podval/tools/test/testproject/SourceFile.scala[SourceFile],
link:src/test/scala/org/podval/tools/test/testproject/TestProject.scala[TestProject].

=== Dynamic Dependencies
I coded a neat way to add dependencies dynamically,

Code to do this is in
link:src/main/scala/org/podval/tools/build/[org.podval.tools.build].
It can:

- detect versions of Scala and specific dependencies;
- add dependencies to configurations;
- expand the classpath.

This allows the plugin to add dependencies
with correct versions and built for correct version of Scala
which may be different from the one
plugin uses, so that Scala 2.12 can be supported.
Support for Scala 2.12 was https://github.com/dubinsky/scalajs-gradle/issues/9[requested]
by https://github.com/machaval[machaval] - thanks for the encouragement!

Classpath expansion allows the plugin to use classes from dependencies
that are added dynamically, but since they become available only after
classpath is expanded, they can only be used indirectly;
that is why such classes are only mentioned by name in dedicated intermediate classes:

- `RunTestClassProcessor` uses `ExceptionConverter`, which uses
`JUnitFrameworkComparisonFailureConverter` and friends, which mention
test framework-specific exceptions;
- Scala.js tasks use `ScalaJSCommon` and friends,
which mention Scala.js-specific classes.

=== Scala 2.12
When running on JVM (and not on Scala.js), tests are forked into a separate JVM.
Code involved in this is running on the project's, not the plugin's, version of Scala.

If the project uses Scala 2.13, Scala 3 classes like `scala/runtime/LazyVals$`
are missing; this is remedied by adding Scala 3 library to the
worker's implementation classpath in `TestFramework`.

If that version is 2.12, any use of 2.13-exclusive features breaks the code,
so I wrote it defensively,
to support 2.12 even though the code was compiled by Scala 3.
Essentially, I use arrays and my own implementations of the array operations
(see link:src/main/scala/org/podval/tools/util/Scala212Collections.scala[Scala212Collections]).

Some of the issues:

- java.lang.NoClassDefFoundError: scala/collection/StringOps$
- java.lang.NoClassDefFoundError: scala/collection/IterableOnce
- java.lang.NoSuchMethodError: scala.Predef$.refArrayOps()
- java.lang.NoSuchMethodError: scala.Predef$.wrapRefArray()
- java.lang.NoSuchMethodError: scala.collection.immutable.Map.updated()

Affected code:

- FrameworkDescriptor
- OptionStyle
- DryRunSbtTask
- RunTestClassProcessor
- Fingerprints
- Selectors
- TaskDefs
- TestClassRunForking

Some of the affected code runs even when using Scala.js,
and it works without those compatibility changes;
this is probably because within the JVM running Gradle,
Scala 2.13 library is on the classpath, even if the project uses Scala 2.12...

I'd rather uglify my code a little than fight with classpath though ;)

=== Nested Tasks
`ScalaCheck` processes test _methods_ as nested tasks;
other frameworks just run them and report the results via event handler.

`uTest `uses `NestedTestSelector` for this, while others use `TestSelector`.

`ScalaTest` does not return nested tasks for nested suites
(or anything, according to the documentation of its Runner);
events for the tests in the nested suites have `NestedTestSelector`.

=== JUnit4 Test Names
`JUnit4` - and thus `MUnit` which is based on it - set both the event's
`fullyQualifiedName` and the `selector` to something like <class name>.<method name>;
method names like this just look stupid,
but class names look like new classes to Gradle (since the event fingerprint says so),
which corrupts test reports.
I had to work around this.

=== JUnit4 for Scala.js Throwable
It is possible, albeit not nice, for the test framework to not populate
the `event.throwable` of the `Failure` event;
`JUnit4 for Scala.js` used to do this (see https://github.com/scala-js/scala-js/pull/5132).

Gradle treats a test as failed only when it receives a `throwable` for the test -
otherwise, although XML report does record the failure, HTML report does not,
nor does Gradle build fail.

This is why I supply a synthesized event for _method_ failures
if one did not come up from the framework.

[#junit4-scalajs-scala-2]
=== JUnit4 for Scala.js and Scala 2
Turns out, `JUnit4 for Scala.js` assumes existence of a `bootstrapper`
in every test class - apparently, because test discovery for `JUnit4`
is based on annotations, and reflection on Scala.js is not powerful enough,
so tests are pre-discovered _at compile time_,
and JUnit4-specific bootstrappers generated for them.

On Scala 3, bootstrappers are generated by the `Scala.js` compiler;
on Scala 2, they are not, resulting in:

[source]
----
Error while loading test class org.podval.tools.test.JUnit4ScalaJSTest failed:
java.lang.ClassNotFoundException: Cannot find org.podval.tools.test.JUnit4ScalaJSTest$scalajs$junit$bootstrapper$
  at org.scalajs.junit.JUnitTask.loadBootstrapper(main.js:13275)
  at org.scalajs.junit.JUnitTask.execute(main.js:13365)
----

To get the bootsrappers generated on Scala 2,
a dedicated Scala compiler plugin has to be added: `scalajs-junit-test-plugin`.
This compiler plugin can _only_ be added when `JUnit4 for Scala.js`
is actually on the classpath - or Scala compiler breaks ;)

see:

- https://github.com/scala-js/scala-js/issues/2937
- https://github.com/scala-js/scala-js/commit/269d1aaf1fa20afbcc3940b9dba58e99ee010dc1
- https://github.com/scala-js/scala-js/issues/4191

[#test-detection]
=== Test Detection
Plugin needs to associate a test framework and a fingerprint with each test class,
so it uses its own test detector.

This is why file-name based test scan is not supported
(`isScanForTestClasses` must be at its default value `true`):
name of the test class is not sufficient to determine which test framework
the class belongs to.

This is also why `JUnit5` is not supported:
it insists on discovering the tests itself, as a comment on the `JupiterTestFingerprint.annotationName()` says:

> return The name of this class. This is to ensure that SBT does not find
> any tests so that we can use JUnit Jupiter's test discovery mechanism.

Well, mission accomplished: my test detector does not find any tests either.

Originally, I coded a test detection mechanism that used
analysis file generated by the Scala compiler.
This code was later replaced with a traditional mechanism
based on scanning the class files,
similar to the mechanism used by Gradle for test detection with `JUnit4` and `TestNG`.

If a class file is recognized by more than one framework
(e.g. `MUnit` tests, which are also `JUnit4` tests),
it is attributed to the framework whose fingerprint is closer to
the test class in the hierarchy (e.g. `MUnit`).

If a test class is encountered with more than one framework claiming it
at the same distance in the hierarchy
(which does not happen naturally, but can be constructed),
mistake is assumed, a warning is issued, and the class is ignored.

On `Scala.js`, annotation are not available at runtime
(Scala.js compiler does not add `RuntimeVisibleAnnotations` to the class file),
so this mechanism alone does not detect tests that are marked as such
using annotations.

Currently, the only test framework that marks tests as tests using annotations
is `JUnit4 for Scala.js`.
When `JUnit4 for Scala.js` is on the classpath,
for each test class candidate
plugin looks for the bootstrapper left behind by the Scala.js compiler
(or, on Scala 2, Scala compiler plugin that generates bootstrappers).
Presence of a bootstrapper `TestClass$scalajs$junit$bootstrapper$`
is treated as a presence of the `@Test` annotation on `TestClass`,
which marks it as a test belonging to the `JUnit4 for Scala.js` test framework.

=== Gradle Internals
To stop tests from being forked - which is needed to run tests on Scala.js -
I had to fork `org.gradle.api.internal.tasks.testing.detection.DefaultTestExecuter`
(see link:src/main/scala/org/podval/tools/test/task/DefaultTestExecuter.scala[DefaultTestExecuter]).
This is suboptimal, since I now have to track changes to the forked class.
My proposal to expose an extension point that would allow to avoid the fork was rejected:
https://github.com/gradle/gradle/issues/32666[32666],
https://github.com/gradle/gradle/pull/32656[32656];
that made it pretty clear that other modifications to Gradle that would make my code
cleaner would be to, so I did not even bother;
here are examples of resulting ugliness:

- to determine if Gradle is being run by IntelliJ Idea
I had to access non-public classes and methods using reflection
in link:src/main/scala/org/podval/tools/test/task/IntelliJIdea.scala[IntelliJIdea];
- to add to the implementation class path of `WorkerProcessBuilder`,
I had to use reflection in
link:src/main/scala/org/podval/tools/test/task/SbtTestFramework.scala[SbtTestFramework];
- to set test framework on the test task, I had to use reflection
in link:src/main/scala/org/podval/tools/test/task/TestTask.scala[TestTask];
- to set options on the test framework, I copied
`org.gradle.api.tasks.testing.Test.options`: it is private and too short to bother with reflection;
- to call `ForkedTestClasspath.getApplicationClasspath()` I had to use reflection,
since it returns `org.gradle.internal.impldep.com.google.common.collect.ImmutableList`,
which is not accessible from the plugin and results in `java.lang.NoSuchMethodError`;
- since Gradle's internal copy of `org.ow2.asm:asm` is under `impldep` and is not accessible to the plugin, I had to add an explicit dependency on `org.ow2.asm:asm`;
- `org.gradle.api.tasks.testing.Test.testsAreNotFiltered()` calls `Test.noCategoryOrTagOrGroupSpecified()`,
which recognizes only the test frameworks explicitly supported by Gradle (`JUnit` and `TestNG`); since I can not override it, I just use
`org.gradle.api.tasks.testing.junit.JUnitOptions` as `SbtTestFrameworkOptions`.

=== AsciiDoc
GitHub stupidly disables AsciDoc includes in README;
see https://github.com/github/markup/issues/1095.

One include (of the `versions.adoc` in `README.adoc`.)
is not enough to bother with https://github.com/asciidoctor/asciidoctor-reducer[AsciiDoctor Reducer],
so I just patch the Readme.adoc...

I also write versions to `gradle.properties` and use them in `gradle.build`.
