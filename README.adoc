= Gradle plugin for Scala.js
:toc:
:toclevels: 4
:toc: preamble
// INCLUDED ATTRIBUTES
:version-gradle: 8.14
:version-plugin: 0.7.0
:version-scala: 3.7.0
:version-scala2-minor: 2.13
:version-scala2: 2.13.16
:version-sbt-test-interface: 1.0
:version-scalajs: 1.19.0
:version-scalajs-dom: 2.8.0
:version-scalajs-env-jsdom-nodejs: 1.1.0
:version-node: 16.19.1
:version-scala-parallel-collections: 1.2.0
:version-scala-native: 0.5.7
:version-junit: 4.13.2
:version-framework-junit4: 0.13.3
:version-framework-junit4-scalajs: 1.19.0
:version-framework-munit: 1.1.1
:version-framework-scalacheck: 1.18.1
:version-framework-scalatest: 3.2.19
:version-framework-specs2: 5.6.3
:version-framework-specs2-scala2: 4.20.9
:version-framework-utest: 0.8.5
:version-framework-zio-test: 2.1.17
:attribute-scalajsBackendProperty: org.podval.tools.scalajs.backend
// INCLUDED ATTRIBUTES

image::https://github.com/dubinsky/scalajs-gradle/actions/workflows/CI.yaml/badge.svg[]

== Summary

This is a `Gradle` plugin that supports:

- compiling, linking and running `Scala.js` code;
- testing it using `sbt`-compatible testing frameworks;
- testing plain Scala code (without Scala.js) using `sbt`-compatible testing frameworks.

Currently, plugin does NOT support Gradle projects that
contain both JVM and Scala.js code;
this is https://github.com/dubinsky/scalajs-gradle/issues/4[in the works].

If needed, plugin automatically:

- adds needed `Scala.js` dependencies that were not added explicitly;
- configures `Scala` compiler for `Scala.js`;
- retrieves and installs `Node.js`;
- installs configured Node modules using `npm`.

Plugin integrates with:

- `Gradle` test task configuration, test filtering, tagging, logging and reporting;
- `IntelliJ` Idea test running and reporting.

Plugin works with:

- `Gradle` {version-gradle};
- `Scala.js` 1.x;
- `Node.js` 16.x.

Plugin itself is written in Scala 3.
Project that the plugin is _applied_ to can use Scala 3, 2.13 or 2.12.
Plugin is not compatible with other Gradle plugins that bring Scala 2.12 or earlier onto the _buildScript_ classpath.

Gradle build file snippets below use the `Groovy` syntax, not the `Kotlin` one.

== Motivation

I dislike untyped languages, so if I _have_ to write `Javascript`,
I want to be able to do it in `Scala`;
thanks to https://www.scala-js.org[Scala.js], this is possible.

I http://dub.podval.org/2011/11/08/sbt-why.html[dislike]
https://www.scala-sbt.org[sbt] -
the https://www.scala-js.org/doc/project[official build tool] of Scala.js,
which uses
https://github.com/scala-js/scala-js/tree/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin[Scala.js sbt plugin];
I want to be able to use my preferred build tool - https://gradle.org[Gradle].

Existing Scala.js Gradle https://github.com/gtache/scalajs-gradle[plugin]
seems to be no longer maintained.

Hence, this plugin.

Plugin supports running tests using `sbt`-compatible testing frameworks
in a way integrated with `Gradle` and `IntelliJ Idea` _with or without_ Scala.js:
for plain Scala projects, Scala.js support can be disabled.

Multiple test frameworks can be used in the same project at the same time
(supporting this probably is not a critical requirement,
but sbt does it, so I must too ;)).

For years, I used https://github.com/maiflai/gradle-scalatest[Gradle ScalaTest plugin]
to run my Scala Tests.
Since my plugin integrates with Gradle - and through it, with IntelliJ Idea -
some of the issues that that plugin has my does not:
https://github.com/maiflai/gradle-scalatest/issues/67[Test events were not received],
https://github.com/maiflai/gradle-scalatest/issues/69[ASCII Control Characters Printed].

I never tried an alternative ScalaTest integration
https://github.com/helmethair-co/scalatest-junit-runner[scalatest-junit-runner],
and if you need `JUnit5` _that_ is probably the way to go,
since my plugin does not support `JUnit5`
(it does support `Scala.js` though :)).

== Applying to a Gradle Project

Plugin is https://plugins.gradle.org/plugin/org.podval.tools.scalajs[published]
on the Gradle Plugin Portal; to apply it to a Gradle project:

[source,groovy,subs="+attributes"]
----
plugins {
  id 'org.podval.tools.scalajs' version '{version-plugin}'
}
----

Plugin will automatically apply the `Scala` plugin to the project,
so there is no need to manually list `id 'scala'` in the `plugins` block -
but there is no harm in it either;
either way, it is the responsibility of the project using the plugin
to add a standard `Scala` library dependency that the Scala plugin requires.

TODO document modes

Unless `Scala.js` support is disabled, plugin will run in Scala.js mode;
to disable Scala.js and use the plugin for testing
plain Scala code with `sbt`-compatible testing frameworks,
put the following into the `gradle.properties` file of the project:

[source,properties,subs="+attributes"]
----
{attribute-scalajsBackendProperty}=JVM
----

== Dependencies

Plugin automatically adds certain dependencies to various Gradle configurations
if they are not added explicitly.

In the examples below, latest versions of all dependencies are used.

Unless you want to override a version of some dependency that the plugin adds,
the only dependencies you need to add to the project are
the Scala library and test framework(s) that you use.

=== JVM

When running on JVM, plugin adds SBT Test Interface
`org.scala-sbt:test-interface:1.0` to the `testImplementation`
configuration: it is used by the plugin to run the tests,
and is normally brought in by the test frameworks themselves,
but since `ScalaTest` does not bring it in,
plugin adds it.

When running on Scala.js, its Scala.js analogue
`org.scala-js:scalajs-test-interface` is brought in transitively
by the Scala.js Test Adapter `org.scala-js:scalajs-sbt-test-adapter`
(among others), which plugin adds.

=== Scala.js

Scala.js dependencies are added only if Scala.js is enabled;
if `scalajs-library` dependency is specified explicitly,
plugin uses the same version for all the Scala.js dependencies that it adds.

When Scala.js is enabled, artifact is suffixed with `_sjs1`;
for instance, `org.scalatest:scalatest_sjs1_3` instead of `org.scalatest:scalatest_3`.
For Scala 2.13, use `_2.13` artifacts instead of the `_3` ones; for Scala 2.12 - `_2.12`.
Same rules apply to the test framework dependencies listed in the <<test-frameworks>> section.

When running on Scala.js, plugin creates two configurations in the project:
- `scalajs` - for Scala.js dependencies used by the plugin itself;
- `scalajsCompilerPlugins` - for Scala compiler plugins needed for compiling
Scala.js on Scala 2;
pre-existing `scalaCompilerPlugins` configuration is not used,
since it would add the plugins to all Scala compilation tasks,
which is not correct for the projects that contain both JVM and Scala.js code.

Table below lists what is added to what configuration when running on Scala.js.

[%autowidth]
|===
|Name |goup:artifact |Configuration |Notes

|Scala.js Compiler
|org.scala-js:scalajs-compiler
|scalajsCompilerPlugins
|only for Scala 2

|Scala.js JUnit Compiler Plugin
|org.scala-js:scalajs-junit-test-plugin
|scalajsCompilerPlugins
|only for Scala 2 and only if JUnit4 for Scala.js is used

|Scala.js Linker
|org.scala-js:scalajs-linker
|scalajs
|

|Scala.js Node.js Environment
|org.scala-js:scalajs-env-jsdom-nodejs
|scalajs
|

|Scala.js Test Adapter
|org.scala-js:scalajs-sbt-test-adapter
|scalajs
|

|Scala.js-compiled Scala Library
|org.scala-lang:scala3-library_sjs1
|implementation
|only for Scala 3

|Scala.js Library
|org.scala-js:scalajs-library
|implementation
|

|Scala.js-compiled DOM Library
|org.scala-js:scalajs-dom_sjs1
|implementation
|

|Scala.js Test Bridge
|org.scala-js:scalajs-test-bridge
|testImplementation
|

|===

=== Scala 3 with Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala}'
final String scala2versionMinor = '{version-scala2-minor}'
final String scalaJsVersion     = '{version-scalajs}'

dependencies {
  scalajs "org.scala-js:scalajs-linker_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-sbt-test-adapter_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-env-jsdom-nodejs_$scala2versionMinor:{version-scalajs-env-jsdom-nodejs}"

  implementation "org.scala-lang:scala3-library_3:$scalaVersion"
  implementation "org.scala-lang:scala3-library_sjs1_3:$scalaVersion"
  implementation "org.scala-js:scalajs-library_$scala2versionMinor:$scalaJsVersion"
  implementation "org.scala-js:scalajs-dom_sjs1_3:{version-scalajs-dom}"

  testImplementation "org.scala-js:scalajs-test-bridge_$scala2versionMinor:$scalaJsVersion"

  // Test framework(s) you use:
  /* JUnit4.js */  testImplementation "org.scala-js:scalajs-junit-test-runtime_$scala2versionMinor:{version-framework-junit4-scalajs}"
  /* MUnit */      testImplementation 'org.scalameta:munit_sjs1_3:{version-framework-munit}'
  /* ScalaCheck */ testImplementation 'org.scalacheck:scalacheck_sjs1_3:{version-framework-scalacheck}'
  /* ScalaTest */  testImplementation 'org.scalatest:scalatest_sjs1_3:{version-framework-scalatest}'
  /* specs2 */     testImplementation 'org.specs2:specs2-core_sjs1_3:{version-framework-specs2}'
  /* uTest */      testImplementation 'com.lihaoyi:utest_sjs1_3:{version-framework-utest}'
}
----

=== Scala 3 without Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala}'

dependencies {
  implementation "org.scala-lang:scala3-library_3:$scalaVersion"

  testImplementation 'org.scala-sbt:test-interface:{version-sbt-test-interface}'

  // Test framework(s) you use:
  /* JUnit4 */     testImplementation "com.github.sbt:junit-interface:{version-framework-junit4}"
  /* MUnit */      testImplementation 'org.scalameta:munit_3:{version-framework-munit}'
  /* ScalaCheck */ testImplementation 'org.scalacheck:scalacheck_3:{version-framework-scalacheck}'
  /* ScalaTest */  testImplementation 'org.scalatest:scalatest_3:{version-framework-scalatest}'
  /* specs2 */     testImplementation 'org.specs2:specs2-core_3:{version-framework-specs2}'
  /* uTest */      testImplementation 'com.lihaoyi:utest_3:{version-framework-utest}'
  /* ZIO Test */   testImplementation 'dev.zio:zio-test-sbt_3:{version-framework-zio-test}'
}
----

=== Scala 2 with Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala2}'
final String scala2versionMinor = '{version-scala2-minor}'
final String scalaJsVersion     = '{version-scalajs}'

dependencies {
  scalajs "org.scala-js:scalajs-linker_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-sbt-test-adapter_$scala2versionMinor:$scalaJsVersion"
  scalajs "org.scala-js:scalajs-env-jsdom-nodejs_$scala2versionMinor:{version-scalajs-env-jsdom-nodejs}"

  scalajsCompilerPlugins "org.scala-js:scalajs-compiler_$scalaVersion:$scalaJsVersion"
  scalajsCompilerPlugins "org.scala-js:scalajs-junit-test-plugin_$scalaVersion:$scalaJsVersion"

  implementation "org.scala-lang:scala-library:$scalaVersion"
  implementation "org.scala-js:scalajs-library_$scala2versionMinor:$scalaJsVersion"
  implementation "org.scala-js:scalajs-dom_sjs1_$scala2versionMinor:{version-scalajs-dom}"

  testImplementation "org.scala-js:scalajs-test-bridge_$scala2versionMinor:$scalaJsVersion"

  // Test framework(s) you use:
  /* JUnit4.js */  testImplementation "org.scala-js:scalajs-junit-test-runtime_$scala2versionMinor:{version-framework-junit4-scalajs}"
  /* MUnit */      testImplementation "org.scalameta:munit_sjs1_$scala2versionMinor:{version-framework-munit}"
  /* ScalaCheck */ testImplementation "org.scalacheck:scalacheck_sjs1_$scala2versionMinor:{version-framework-scalacheck}"
  /* ScalaTest */  testImplementation "org.scalatest:scalatest_sjs1_$scala2versionMinor:{version-framework-scalatest}"
  /* specs2 */     testImplementation "org.specs2:specs2-core_sjs1_$scala2versionMinor:{version-framework-specs2-scala2}"
  /* uTest */      testImplementation "com.lihaoyi:utest_sjs1_$scala2versionMinor:{version-framework-utest}"
}
----

=== Scala 2 without Scala.js

[source,groovy,subs="+attributes"]
----
final String scalaVersion       = '{version-scala2}'
final String scala2versionMinor = '{version-scala2-minor}'

dependencies {
  implementation "org.scala-lang:scala-library:$scalaVersion"

  testImplementation 'org.scala-sbt:test-interface:{version-sbt-test-interface}'

  // Test framework(s) you use:
  /* MUnit */      testImplementation "org.scalameta:munit_$scala2versionMinor:{version-framework-munit}"
  /* ScalaCheck */ testImplementation "org.scalacheck:scalacheck_$scala2versionMinor:{version-framework-scalacheck}"
  /* ScalaTest */  testImplementation "org.scalatest:scalatest_$scala2versionMinor:{version-framework-scalatest}"
  /* specs2 */     testImplementation "org.specs2:specs2-core_$scala2versionMinor:{version-framework-specs2-scala2}"
  /* uTest */      testImplementation "com.lihaoyi:utest_$scala2versionMinor:{version-framework-utest}"
  /* ZIO Test */   testImplementation "dev.zio:zio-test-sbt_$scala2versionMinor:{version-framework-zio-test}"
}
----

== Scala.js
Ths section applies only when Scala.js support is enabled.

=== Compiling
To support Scala.js, Scala compiler needs to be configured to produce both the `class` _and_ `sjsir` files.

==== Scala 3

If the project uses Scala 3, all it takes is to pass `-scalajs` option to the Scala compiler, since
Scala 3 compiler has Scala.js support built in:

[source,groovy]
----
tasks.withType(ScalaCompile) {
  scalaCompileOptions.with {
    additionalParameters = [ '-scalajs' ]
  }
}
----

Plugin automatically adds this option to the main and test Scala compilation tasks if it is not present.

==== Scala 2
If the project uses Scala 2, Scala.js compiler plugin dependency needs to be declared:

[source,groovy,subs="+attributes"]
----
dependencies {
  scalajsCompilerPlugins "org.scala-js:scalajs-compiler_$scalaVersion:{version-scalajs}"
}
----

Plugin does this automatically unless a dependency on `scalajs-compiler` is declared explicitly.

If the project uses Scala 2 _and_ JUnit 4 for Scala.js,
a JUnit Scala compiler plugin is also needed:

[source,groovy,subs="+attributes"]
----
dependencies {
  scalajsCompilerPlugins "org.scala-js:scalajs-junit-test-plugin_$scalaVersion:{version-scalajs}"
}
----

Plugin adds this automatically also.

There is no need to add `-Xplugin:` Scala compiler parameters for the compiler plugins.

=== Linking

For linking of the main code, plugin adds `link` task of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSLinkMainTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkMainTask];
all tasks of this type automatically depend on the `classes` task.

For linking of the test code, plugin adds `testLink` task of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSLinkTestTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkTestTask];
all tasks of this type automatically depend on the `testClasses` task.

Link tasks exposes a property `JSDirectory` that points to a directory
with the resulting JavaScript, so that it can be copied where needed.
For example:

[source,groovy]
----
link.doLast {
  project.sync {
    from link.JSDirectory
    into jsDirectory
  }
}
----

Link tasks have a number of properties that can be used to configure linking.
Configurable properties with their defaults are:

[source,groovy]
----
link {
  optimization     = 'Fast'          // one of: 'Fast', 'Full'
  moduleKind       = 'NoModule'      // one of: 'NoModule', 'ESModule', 'CommonJSModule'
  moduleSplitStyle = 'FewestModules' // one of: 'FewestModules', 'SmallestModules'
  prettyPrint      = false
}
----

Setting `optimization` to `Full` enables:

- `Semantics.optimized`;
- `checkIR`;
- Closure Compiler (unless `moduleKind` is set to `ESModule`).

For `ScalaJSLinkMainTask` tasks, a list of module initializers may also be configured:

[source,groovy]
----
moduleInitializers {
  main {
    className = '<fully qualified class name>'
    mainMethodName = 'main'
    mainMethodHasArgs = false
  }
}
----

Name of the module initializer ('main' in the example above) becomes the module id.

=== Running

Plugin adds `run` task for running the main code
(if it is an application and not a library);
this task automatically depends on the `link` task.

Additional tasks of type
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSRunMainTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSRunMainTask]
can be added manually;
their dependency on a corresponding `ScalaJSLinkMainTask` task must be set manually too.

=== Node.js

For running `Scala.js` code and tests, plugin uses `Node.js`.

In Scala.js mode, plugin adds `node` extension to the project.
This extension can be used to specify the version of Node.js to use and Node modules to install:

[source,groovy,subs="+attributes"]
----
node {
  version = '{version-node}'
  modules = ['jsdom']
}
----

If Node.js version is not specified, plugin uses "ambient" Node.js -
the one installed on the machine where it is running,
or, if none is available, installs the default version ({version-node}).
If Node.js version is specified, plugin install that version.

Node is installed under `~/.gradle/nodejs`.

Scala.js does not support versions of Node.js newer than "{version-node}",
so none of the "17.9.1", "18.15.0", "19.8.1".
I do not know anything about Node.js, and find this surprising -
but I am sure there is a good technical or political reason for this ;)

If no Node modules to install are listed, plugin installs the `jsdom` module,
which is required for `org.scala-js:scalajs-env-jsdom-nodejs`.

To get better traces, one can add `source-map-support` module.

Node modules for the project are installed in the `node_modules`
directory in the project root.

If `package.json` file does not exist, plugin runs `npm init private`.

Plugin adds tasks `node` and `npm` for executing `node` and `npm` commands
using the same version of Node.js that is used by the plugin;
those tasks can be used from the command line like this:

[source,shell]
----
./gradlew npm --npm-arguments 'version'
./gradlew node --node-arguments '...'
----

== Testing

=== Test Task
Test task added by the plugin is derived from the normal Gradle `test` task,
and can be configured  in the traditional way - with some limitations:

- plugin applies its own Gradle test framework (`useSbt`) to each test task;
re-configuring the Gradle test framework (via `useJUnit`, `useTestNG` or `useJUnitPlatform`) is not supported;
- `isScanForTestClasses` must be at its default value `true`.
- ScalaJS tests _must_ run in the same JVM where they are discovered,
so they are not forked, and forking configuration is ignored.

Dry run (`test.dryRun=true` or `--test-dry-run` command line option) is supported.

Test filtering and tagging are supported to the extent that the individual
test frameworks support them; see <<test-filtering>>, <<test-tagging>>
and <<test-frameworks>>.

If there is a need to have test runs with different configurations,
more testing tasks can be added manually.

For plain Scala projects (no Scala.js), the type of the test task is
link:src/main/scala/org/podval/tools/scalajsplugin/jvm/JvmTestTask.scala[org.podval.tools.scalajsplugin.jvm.JvmTestTask].
Any such task will automatically depend on the `testClasses` task (and `testRuntimeClassPath`).

For Scala.js projects the type of the test task is
link:src/main/scala/org/podval/tools/scalajsplugin/scalajs/ScalaJSTestTask.scala[org.podval.tools.scalajsplugin.scalajs.ScalaJSTestTask].
Such test tasks have to depend on a
`org.podval.tools.scalajsplugin.scalajs.ScalaJSLinkTestTask task`.
The `test` task added by the plugin does it automatically;
for manually added tasks this dependency has to be added manually.

[#test-filtering]
=== Test Filtering

Gradle uses three sets of patterns to filter tests by names;
two of them - `includeTestsMatching` and `excludeTestsMatching` -
are set in the Gradle build file:

[source, groovy]
----
test {
  filter {
    includeTestsMatching "org.podval.tools.test.SomeTestClass.success"
    includeTestsMatching "org.podval.tools.test.SomeTestClass.failure"
    excludeTestsMatching "OtherTestClass"
  }
}
----

The third one is set via a command-line option `--tests`.

Inclusion rules are:

- if both build file and the command line inclusions are specified,
to be included, a test must match both.
- if no inclusions nor exclusions are specified, all tests are included.
- if only inclusions are specified, only tests matching one of them are included.
- if only exclusions are specified, only tests not matching any of them are included.
- if both inclusions and exclusions are specified, only tests matching one of the inclusions and not matching any of the exclusions are included.

Gradle inclusion/exclusion patterns can contain wildcards "*";
semantics of matching against those patterns is complicated,
sometimes surprising and difficult (for me) to understand;
that is why I followed Gradle implementation as closely as possible.
Plugin implements test _class_ inclusion/exclusion itself,
but individual test _case_ inclusion/exclusion is handled by the test framework used.

SBT test interface that the plugin uses to communicate with the test frameworks
has means of expressing that a test case with specific name is to be included
(https://github.com/sbt/test-interface/blob/master/src/main/java/sbt/testing/TestSelector.java[TestSelector])
and that test cases whose names contain a specific string are to be included
(https://github.com/sbt/test-interface/blob/master/src/main/java/sbt/testing/TestWildcardSelector.java[TestWildcardSelector]);
it does not have any means of expressing which test cases are to be excluded.

Plugin does not have access to the list of test case names
(which are framework-dependent),
so, even though I try to translate Gradle filtering to the SBT test interface filtering as close as possible, when test case filtering is involved,
this translation can in general case lose fidelity.
My immediate goal was to make sure the filtering scenarios that are used in practice
work as intended; turns out, infidelities in the implementation of test case filtering
in specific test frameworks make even that impossible in some cases,
as is detailed below.

The following patterns specify test classes to run:

- `"*"`: all tests, just as if no includes are specified;
- `"*IntegrationTest"`: classes whose named end with "IntegrationTest";
- `"Scala*"`: classes whose name starts with "Scala";
- `"org.podval.tools.test.Scala*"`: classes in specified package whose name starts with "Scala";
- `"org.podval.tools.test.*"`: tests in specified package (used by IntelliJ Idea, see <<intellij-idea-integration>>);
- `"org.podval.tools.test.ScalaTest"`: tests in specified class (used by IntelliJ Idea, see <<intellij-idea-integration>>).

All these patterns work as intended.

The following patterns specify test cases to run:

- `"org.podval.tools.test.SomeTestClass.success"`: specified test case in specified class (used by IntelliJ Idea, see <<intellij-idea-integration>>);
- `"org.podval.tools.test.SomeTestClass.succ*"`: test cases whose names start with "succ" in specified class.

With these patterns, what actually happens depends on the
fidelity with which test framework used implements
even the restricted test case selection means of the SBT test interface.

[#test-tagging]
=== Test Tagging

Names of the tags to include and exclude in the run are specified in:

[source,groovy]
----
test {
  useSbt {
    includeCategories = ["itag1", "itag2"]
    excludeCategories = ["etag1", "etag2"]
  }
}
----

Inclusion rules are:

- if no inclusions nor exclusions are specified, all tests are included.
- if only inclusions are specified, only tests tagged with one of them are included.
- if only exclusions are specified, only tests not tagged with any of them are included.
- if both inclusions and exclusions are specified, only tests tagged with one of the inclusions and not tagged with any of the exclusions are included.

=== Skipped Tests
When running some test methods explicitly included by a filter,
I do not want to see skipped methods mentioned in the test report
just as I do not want to see other skipped test classes there.

I do want to see tests explicitly ignored in code
(e.g., in ScalaTest, or JUnit4's falsified assumptions).

During a dry run, though, I want to see _everything_ that was skipped,
including test classes that were skipped entirely;
for such, a test case named `dry run` is reported as skipped.

=== Nested Test Suites

Some test frameworks have a notion of _nested test suites_,
where nesting test class aggregates nested test classes.

Plugin supports such scenario and,
when test framework involved provides sufficient information about the tests run,
attributes test cases from the nested suites to them:
test report will have no test cases for the nesting class;
instead, test cases will be reported for the nested classes they belong to.

[#test-frameworks]
== Test Frameworks
Plugin replaces the `test` task with one that supports running
sbt-compatible test frameworks; multiple test frameworks can be used at the same time.

TestNG is not supported: its
https://github.com/sbt/sbt-testng[SBT interface] is long since abandoned.

JUnit5 is not supported, since it insists on using its own test discovery mechanism.
Both Gradle and IntelliJ Idea support JUnit5 out of the box,
and since there is no JUnit5 for Scala.js,
there is not much the plugin can add anyway.

Framework-specific information for the frameworks that _are_ supported follows.

=== Junit4
JUnit4 SBT interface (com.github.sbt:junit-interface)
is a separate project from JUnit4 itself;
SBT interface dependency brings in the underlying framework dependency
`junit:junit` transitively;
its version can be overridden in the Gradle build script.

- coordinates: `com.github.sbt:junit-interface`;
- current version: {version-framework-junit4};
- JVM only, no Scala.js
- Java dependency, no Scala version in the artifact
- test filtering: works fine;
- ignoring a test: not supported;
- assumptions: if falsified, result in a test being skipped: `org.junit.Assume.assumeTrue(false)`;

==== Test Tagging
Tag tests with classes or traits
that do not have to be derived from anything `JUnit4`-specific;
in the Gradle build file, `excludeCategories` and `includeCategories`
list fully-qualified names of tagging classes or traits:
[source, scala]
----
trait IncludedTest
trait ExcludedTest
@org.junit.experimental.categories.Category(Array(
  classOf[org.podval.tools.test.IncludedTest],
  classOf[org.podval.tools.test.ExcludedTest]
))
@Test def excluded(): Unit = ()
----

==== Nested Suites
JUnit4 uses an annotation on the nesting suite to indicate that it
contains nested suites:

[source,scala]
----
@org.junit.runner.RunWith(classOf[org.junit.runners.Suite])
----

and another annotation that lists the nested suites:

[source,scala]
----
@org.junit.runners.Suite.SuiteClasses(Array(
  classOf[JUnit4Nested]
))
----

For example, `JUnit4Nesting` contains `JUnit4Nested`:

[source,scala]
----
@org.junit.runner.RunWith(classOf[org.junit.runners.Suite])
@org.junit.runners.Suite.SuiteClasses(Array(
  classOf[JUnit4Nested]
))
class JUnit4Nesting {
}

import org.junit.Test
import org.junit.Assert.assertTrue

final class JUnit4Nested {
  @Test def success(): Unit = assertTrue("should be true", true)
  @Test def failure(): Unit = assertTrue("should be true", false)
}
----

By default, `JUnit4` 's `sbt` framework
https://github.com/sbt/junit-interface/blob/develop/src/main/java/com/novocode/junit/JUnitRunner.java#L39[ignores] the
`org.junit.runners.Suite` runner; plugin supplies an appropriate
arguments to `JUnit4` to enable it.

=== JUnit4 for Scala.js
JUnit4 for Scala.js is a framework distinct from JUnit4:
it is a partial translation/re-implementation of JUnit4 circa 2015
and has different capabilities.

- coordinates: `org.scala-js:scalajs-junit-test-runtime`;
- current version: {version-scalajs};
- Scala.js only, no JVM;
- Scala dependency, no `sjs1` suffix in the artifact;
- Scala 2 only;
- test filtering: does not support test case selectors and runs all test cases in the class;
- test tagging: not supported;
- nested suites: not supported;
- ignoring tests: not supported;
- assumptions: not supported;

=== MUnit
MUnit uses JUnit internally, and brings in the underlying framework dependency transitively:
on JVM - `junit:junit`; on Scala.js - `org.scala-js:scalajs-junit-test-runtime`;
its version can be overridden in the Gradle build script.

- coordinates: `org.scalameta:munit`;
- current version: {version-framework-munit};
- test filtering: works fine on `JVM`; on `Scala.js`, does not support test case selectors and runs all test cases in the class.
- nested suites: not supported;
- assumptions: not supported;
- ignoring a test `test("test".ignore) {}`;

==== Test Tagging
MUnit is based on JUnit4, so it supports the `Category`-based exclusion and inclusion;
since on Scala.js MUnit uses `JUnit4 for Scala.js`,
which does not support this mechanism,
MUnit does not support it either.

Plugin does not use `Category`-based mechanism;
MUnit provides a different, `Tag`-based mechanism,
and that is what plugin uses.

Tag tests with values that are instances of `munit.Tag`:

[source, scala]
----
val include = new munit.Tag("org.podval.tools.test.ExcludedTest")
val exclude = new munit.Tag("org.podval.tools.test.ExcludedTest")
test("excluded".tag(include).tag(exclude)) {}
----

When tagging classes used for inclusion/exclusion are not available,
MUnit crashes with a `ClassNotFound`.

=== ScalaCheck
- coordinates: `org.scalacheck:scalacheck`;
- current version: {version-framework-scalacheck};
- test filtering functionality is not available:
https://github.com/dubinsky/scalajs-gradle/issues/43[issue];
- test tagging: not supported, but if it is used via another test framework -
like `ScalaTest` or `specs2` - test tagging mechanisms provided by that
framework can be used;
- assumptions: not supported;
- ignoring a test: not supported;

==== Nested Suites
In ScalaCheck, nesting is accomplished by using
`org.scalacheck.Properties.include()`:

[source,scala]
----
object ScalaCheckNesting extends org.scalacheck.Properties("ScalaCheckNesting") {
  include(ScalaCheckNested)
}

object ScalaCheckNested extends org.scalacheck.Properties("ScalaCheckNested") {
  property("success") = org.scalacheck.Prop.passed
  property("failure") = org.scalacheck.Prop.falsified
}
----

With ScalaCheck, nested test cases are attributed to the _nesting_ suite -
and there is nothing that can be done about it,
since ScalaCheck itself does not keep information about which class a property belongs to;
see https://github.com/typelevel/scalacheck/pull/1107.

=== ScalaTest
- coordinates: `org.scalatest:scalatest`;
- current version:  {version-framework-scalatest};
- test filtering: works fine;
- assumptions: not supported;
- ignoring a test: `ignore should "be ignored"`;

==== Test Tagging
Tag tests with objects that extend `org.scalatest.Tag`:
[source, scala]
----
object Include extends org.scalatest.Tag("org.podval.tools.test.IncludedTest")
object Exclude extends org.scalatest.Tag("org.podval.tools.test.ExcludedTest")
"excluded" should "not run" taggedAs(Include, Exclude) in {  true shouldBe false }
----

==== Nested Suites
In `ScalaTest`, nesting of the test suites is indicated by
deriving the nesting class from `org.scalatest.Suites`
and listing the nested suites in its constructor:

[source,scala]
----
class ScalaTestNesting extends org.scalatest.Suites(
  new ScalaTestNested
)
----

=== Specs2
- coordinates: `org.specs2:specs2-core`;
- current version: {version-framework-specs2};
- latest version for Scala 2: 4.20.9;
- test filtering: works fine;
- nested suites: not supported;
- assumptions: not supported;
- ignoring a test: not supported;

==== Test Tagging
Tag tests with tag names:
[source,scala]
----
exclude tests tagged for exclusion $excludedTest ${tag(
  "org.podval.tools.test.IncludedTest",
  "org.podval.tools.test.ExcludedTest"
)}
----

=== uTest
- coordinates: `com.lihaoyi:utest`;
- current version: {version-framework-utest};
- test filtering: does not support test case selectors and runs all test cases in the class.
- test tagging: not supported;

==== Nested Suites
Only test suites defined in the same test class can be nested:

[source,scala]
----
import utest._

object UTestNesting extends TestSuite {
  val tests: Tests = Tests {
    test("UTestNesting") {
      test("UTestNested") {
        test("success") { assert(1 == 1) }
        test("failure") { assert(1 == 0) }
      }
    }
  }
}
----

=== ZIO Test

Issues identified and fixed: https://github.com/dubinsky/scalajs-gradle/issues/45[bug].

Currently, not supported on Scala.js because of a bug
https://github.com/dubinsky/scalajs-gradle/issues/37[issues/37].

- coordinates: `dev.zio:zio-test-sbt`;
- current version: {version-framework-zio-test};
- test filtering: treats specific test case inclusions as wildcards,
and instead of running just the named test cases runs all whose names contain
the specified string, because the only test case name-based filtering that ZIO Test supports is "search terms", which
https://github.com/zio/zio/blob/series/2.x/test/shared/src/main/scala/zio/test/FilteredSpec.scala#L32[work as wildcards];
- ignoring a test: `test("ignored") { ... } @@ zio.test.TestAspect.ignore`;
- assumption: `test("assumption") { ... } @@ zio.test.TestAspect.ifProp("property")(string => false)`

==== Test Tagging
Tag tests with tag names using `TestAspect.tag`:
[source, scala]
----
test("tagged") { ... } @@ TestAspect.tag(
  "org.podval.tools.test.IncludedTest",
  "org.podval.tools.test.ExcludedTest"
)
----

==== Nested Suites

[source,scala]
----
import zio.test._

object ZIOTestNesting extends ZIOSpecDefault {
  override def spec: Spec[TestEnvironment, Any] = suite("ZIOTestNesting")(
    ZIOTestNested.spec
  )
}
object ZIOTestNested extends ZIOSpecDefault {
  override def spec: Spec[TestEnvironment, Any] = suite("ZIOTestNested")(
    test("success") { assertTrue(1 == 1) },
    test("failure") { assertTrue(1 == 0) },
  )
}
----

== Test Framework Issues
While working on the plugin, I identified (and sometimes fixed)
issues in the various test frameworks:

- JUnit4 for Scala.js:
_https://github.com/scala-js/scala-js/pull/5132[5132]_,
_https://github.com/scala-js/scala-js/pull/5134[5134]_;

- ZIO:
https://github.com/zio/zio/issues/9629[9629],
_https://github.com/zio/zio/pull/9680[9680]_,
_https://github.com/zio/zio/pull/9756[9756]_;

- ScalaCheck:
https://github.com/typelevel/scalacheck/issues/1105[1105],
_https://github.com/typelevel/scalacheck/pull/1107[1107]_;

- ScalaTest:
https://github.com/scalatest/scalatest/issues/2357[2357];

- MUnit:
_https://github.com/scalameta/munit/pull/918[918]_;

- specs2:
_https://github.com/etorreborre/specs2/pull/1327[1327]_;



[#intellij-idea-integration]
== IntelliJ Idea Integration

Whatever you can run from Idea you can also debug -
unless Scala.js is used:
Scala.js code runs on Node.js, so there is no debugging it - breakpoints have no effect.

As with any other Gradle project imported into Idea, you can run Gradle tasks.

IntelliJ lets you run objects with main methods using either:

- object node in the project tree or
- gutter icon in the object's file

When Scala.js is enabled, objects can not be run this way:
the code needs to be compiled for Scala.js, linked and run on Node.js.
This is what the `run` task added by the plugin is for.

As usual, when you run tests:

- results are displayed in tree form
- test counts are displayed.

As usual, you can run all tests from the project tree using any of the nodes:

[source]
----
<root>
  src
    test
      scala
----

As usual, you can run all tests from a package using the package's node in the project tree.
Idea supplies Gradle test filter "selected.package.*".

As usual, you can run individual test for _the frameworks Idea recognizes_ using either:

- test's node in the project tree or
- gutter icon in the test's file

Idea supplies Gradle test filter "fully.qualified.TestClass".

From the test frameworks this plugin supports,
Idea recognizes:

- JUnit4 (for some reason, tests can not be run from the project tree)
- JUnit4 for Scala.js
- MUnit

Scala plugin for Idea recognizes
(but does nor reflect the results of the previous run in the gutter icon of the test):

- ScalaTest
- Specs2
- uTest

Not recognized are:

- ScalaCheck
- ZIO Test

Since `ZIO Test` tests are  objects with main method,
they can be run from Idea (when not using Scala.js),
but there is no test result tree nor test counts displayed,
and since Gradle is not involved, no test reports.

For `JUnit4` and `JUnit4 for Scala.js`,
Idea also recognizes individual test methods within a test class;
they can be run using their gutter icons.
Idea supplies Gradle test filter "fully.qualified.TestClass.testMethod".

For `MUnit`, only the first test method gets a gutter icon,
but Idea supplies test filter "fully.qualified.TestClass",
so that icon runs the whole class, not the test method it is for.

For `ScalaTest`, every test method gets a gutter icon,
but Idea supplies test filter "fully.qualified.TestClass",
so that icon runs the whole class, not the test method it is for.

For `specs2` and `uTest`, there are no gutter icons for individual test methods.

== Implementation Notes

=== Scala.js Linking
It is reasonably easy - if repetitive - to configure the Scala compiler and add needed Scala.js dependencies by hand;
what really pushed me to build this plugin is the difficulty and ugliness involved in
manually setting up Scala.js linking in a Gradle build script.

I perused the code of:

- https://www.scala-js.org/doc/tutorial/basic[Scala.js Tutorial]
- https://github.com/scala-js/scala-js/tree/main/linker-interface[Scala.js Linker]
- https://github.com/scala-js/scala-js/tree/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin[Scala.js sbt plugin]
- https://github.com/gtache/scalajs-gradle[Old Scala.js Gradle plugin] by https://github.com/gtache[gtache]
- https://github.com/scala-js/scala-js-cli/tree/main/src/main/scala/org/scalajs/cli[Scala.js CLI]

=== Testing

To figure out how `sbt` itself integrates with testing frameworks, I had to untangle some `sbt` code, including:

- `sbt.Defaults`
- `sbt.Tests`
- `sbt.TestRunner`
- `sbt.ForkTests`
- `org.scalajs.sbtplugin.ScalaJSPluginInternal`

Turns out, internals of `sbt` are a maze of twisted (code) passages,
all alike, where pieces of code are stored in key-value maps,
and addition of such maps is used as an override mechanism.
What a disaster!

There are _two_ testing interfaces in `org.scala-sbt:test-interface:1.0`;
I use the one used by the Scala.js sbt plugin - presumably the "new" one ;)

Just being able to run the tests with no integration with
Gradle or IntelliJ Idea seemed suboptimal,
so I decided to look into proper integrations of things like
`org.scala-js:scalajs-sbt-test-adapter` and
https://github.com/sbt/test-interface[org.scala-sbt:test-interface].

I perused code from:

- https://github.com/gradle/gradle[Gradle];
- https://github.com/JetBrains/intellij-community[IntelliJ Idea];
- https://github.com/maiflai/gradle-scalatest[Gradle ScalaTest plugin].

This took _by far_ the most of my time
(and takes up more than 3/4 of the plugin code),
and uncovered a number of surprises.

IntelliJ Idea instruments Gradle test task with its `IJTestEventLogger` -
but _only_ if the task is of type `org.gradle.api.tasks.testing.Test`,
so that is what I derive my test task from.

Once I worked out how to integrate tests on Scala.js with Gardle and IntelliJ Idea,
it was reasonably easy to re-use this integration to run tests
using sbt-compatible frameworks _without_ any Scala.js involved -
in plain Scala projects.

=== Testing on Scala.js

Scala.js tests must be run in the same JVM where their frameworks were instantiated
(see https://github.com/scala-js/scala-js/blob/main/sbt-plugin/src/main/scala/org/scalajs/sbtplugin/ScalaJSPluginInternal.scala#L676[org.scalajs.sbtplugin.ScalaJSPluginInternal]).
`TestExecuter` makes sure that the tests are not forked,
and `TestTask` overrides
`org.gradle.api.tasks.testing.Test.getMaxParallelForks()`
to return `1` on `Scala.js` to prevent `MaxNParallelTestClassProcessor`
from forking.

On JVM, exceptions are serialized in Gradle's `org.gradle.internal.serialize.ExceptionPlaceholder`, which contains lots of details;
on Scala.js, `org.scalajs.testing.common.Serializer.ThrowableSerializer`
turns them all into `org.scalajs.testing.common.Serializer$ThrowableSerializer$$anon$3`;
since source mapping is used only on Scala.js,
there is no point trying to preserve the original exception:
it is already lost;
so just wrap what remains in `TestExecutionException`.

=== Node.js

`Node.js` support that the plugin provides
is heavily inspired by (read: copied and reworked from :))
https://github.com/srs/gradle-node-plugin[gradle-node-plugin].

That plugin is not used directly because its tasks are not reusable
unless the plugin is applied to the project,
and I do not want to apply Node Gradle plugin to every project that uses my
Scala.js Gradle plugin.

Also, I want to be able to run `npm` from within my code without creating tasks.
Also, I would like to be able to use Node available via GraalVM's polyglot support.

My simplified Node support is under 300 lines.

=== Test Run Data
Test detection produces more information than just the class name:

- framework that recognized the test
- fingerprint
- selectors

I need to deliver this additional information to forked test processors.

For a while, I used modified serializer for this;
of course, serializer is hard-coded in the Gradle code,
so to use mine I had to modify three Gradle files...

I even made a https://github.com/gradle/gradle/pull/24088[pull request]
to add flexibility in this regard to Gradle -
but then I realized that I can encode additional information I need
to get to the worker in the test class name!

=== Test Events
Turns out that IntelliJ Idea integration only works when all the calls to
the IJ listener happen from the same thread
(it probably uses some thread-local variable to set up cross-process communications).
Since some of the calls are caused by the call-back from the sbt testing interface's
event handler, I get "Test events were not received" in the Idea test UI.
It would have been nice if this fact was documented somewhere :(
I coded an event queue with its own thread, but then discovered that:

- Gradle provides a mechanism that ensures that all the calls are made from the same thread: `Actor.createActor.getProxy`;
- when tests are forked, `MaxNParallelTestClassProcessor` is used, which already does that, so I do not need to;
- when running on `Scala.js` everything is single-threaded anyway.

=== Test Ids
`org.gradle.internal.remote.internal.hub.DefaultMethodArgsSerializer`
seems to make a decision which serializer registry to use based on the
outcome of the `SerializerRegistry.canSerialize()` call
for the class of the first parameter of a method;
test id is the first parameter of the `TestResultProcessor.output()`, `completed()` and `failure()` calls.
Without some tricks like registering a serializer for `AnyRef` and disambiguating
in the `SerializerRegistry.build()` call,
neither `null` nor `String` are going to work as ids.

This is _probably_ the reason why Gradle:

- makes all test ids `CompositeIdGenerator.CompositeId`
- registers a `Serializer[CompositeIdGenerator.CompositeId]` in `TestEventSerializer`.

Gradle just wants to attract attention to its `TestEventSerializer`,
so it registers serializers for the types
of the first parameters of all methods - including the test ids ;)

And since the minimum of composed is two,
Gradle uses test ids that are composite of two Longs.

AbstractTestTask installs `StateTrackingTestResultProcessor`
which keeps track of all tests that are executing in any `TestWorker`.
That means that test ids must be scoped per `TestWorker`.
Each `TestWorker` has an `idGenerator` which it uses to generate `WorkerTestClassProcessor.workerSuiteId`;
that same `idGenerator` can be used to generate sequential ids
for the tests in the worker,
satisfying the uniqueness requirements - and resulting in the test ids always being
a composite of exactly two Longs!

Because tests are scoped by the workers, it does not seem possible to group test results by framework.

=== Test Output
Since I can not use the real `rootTestSuiteId` that `DefaultTestExecuter`
supplies to the `TestMainAction` - because it is a `String` -
and I am not keen on second-guessing what it is anyway,
I use a `idPlaceholder` in `WorkerTestClassProcessor`
and change it to the real one in `FixUpRootTestOutputTestResultProcessor`.

Gradle controls the formatting of the test output:

- indenting is hard-coded in the
https://github.com/gradle/gradle/blob/master/subprojects/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/TestEventLogger.java#L63[TestEventLogger.onOutput()];
- addition of the test name and the name of the output stream at the top of each indented batch
(output of the same test) is hard-coded in the
https://github.com/gradle/gradle/blob/master/subprojects/testing-base/src/main/java/org/gradle/api/internal/tasks/testing/logging/AbstractTestLogger.java#L51[AbstractTestLogger.logEvent()].

IntelliJ Idea, in `addTestListener.groovy`:

- https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/java/resources/org/jetbrains/plugins/gradle/java/addTestListener.groovy#L30[suppresses]
the output and error events and
- https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/java/resources/org/jetbrains/plugins/gradle/java/addTestListener.groovy#L29[adds]
its own test and output listener
https://github.com/JetBrains/intellij-community/blob/master/plugins/gradle/resources/org/jetbrains/plugins/gradle/IJTestLogger.groovy[IJTestEventLogger]
that does no batching, indenting or adding.

=== Testing the Tests
I coded a neat way to test the plugin itself and
various features of the various frameworks and their support by the plugin:
link:src/test/scala/org/podval/tools/test/testproject/Feature.scala[Feature],
link:src/test/scala/org/podval/tools/test/testproject/Fixture.scala[Fixture],
link:src/test/scala/org/podval/tools/test/testproject/ForClass.scala[ForClass],
link:src/test/scala/org/podval/tools/test/testproject/GroupingFunSpec.scala[GroupingFunSpec],
link:src/test/scala/org/podval/tools/test/testproject/SourceFile.scala[SourceFile],
link:src/test/scala/org/podval/tools/test/testproject/TestProject.scala[TestProject].

=== Dynamic Dependencies
I coded a neat way to add dependencies dynamically,

Code to do this is in
link:src/main/scala/org/podval/tools/build/[org.podval.tools.build].
It can:

- detect versions of Scala and specific dependencies;
- add dependencies to configurations;
- expand the classpath.

This allows the plugin to add dependencies
with correct versions and built for correct version of Scala
which may be different from the one
plugin uses, so that Scala 2.12 can be supported.

Classpath expansion allows the plugin to use classes from dependencies
that are added dynamically, but since they become available only after
classpath is expanded, they can only be used indirectly;
that is why such classes are only mentioned by name in dedicated intermediate classes:

- `RunTestClassProcessor` uses `ExceptionConverter`, which uses
`JUnitFrameworkComparisonFailureConverter` and friends, which mention
test framework-specific exceptions;
- Scala.js tasks use `ScalaJSCommon` and friends,
which mention Scala.js-specific classes.

=== Scala 2.12
When running on JVM (and not on Scala.js), tests are forked into a separate JVM.
Code involved in this is running on the project's, not the plugin's, version of Scala.

If the project uses Scala 2.13, Scala 3 classes like `scala/runtime/LazyVals$`
are missing; this is remedied by adding Scala 3 library to the
worker's implementation classpath in `TestFramework`.

If that version is 2.12, any use of 2.13-exclusive features breaks the code,
so I wrote it defensively,
to support 2.12 even though the code was compiled by Scala 3.
Essentially, I use arrays and my own implementations of the array operations
(see link:src/main/scala/org/podval/tools/util/Scala212Collections.scala[Scala212Collections]).

Some of the issues:

- java.lang.NoClassDefFoundError: scala/collection/StringOps$
- java.lang.NoClassDefFoundError: scala/collection/IterableOnce
- java.lang.NoSuchMethodError: scala.Predef$.refArrayOps()
- java.lang.NoSuchMethodError: scala.Predef$.wrapRefArray()
- java.lang.NoSuchMethodError: scala.collection.immutable.Map.updated()

Affected code:

- FrameworkDescriptor
- OptionStyle
- DryRunSbtTask
- RunTestClassProcessor
- Fingerprints
- Selectors
- TaskDefs
- TestClassRunForking

Some of the affected code runs even when using Scala.js,
and it works without those compatibility changes;
this is probably because within the JVM running Gradle,
Scala 2.13 library is on the classpath, even if the project uses Scala 2.12...

I'd rather uglify my code a little than fight with classpath though ;)

=== Test Tagging
Although it is tempting to help the test frameworks out by
filtering tests based on their tags
returned by the test framework in `task.tags`, it is:

- unnecessary, since all the test frameworks plugin supports
that support tagging accept
arguments that allow them to do the filtering internally;
- destructive, since none of the test frameworks plugin supports
populate `task.tags`, so with explicit tag inclusions, none of the tests run!

[#junit4-scalajs-scala-2]
=== JUnit4 for Scala.js and Scala 2
Turns out, `JUnit4 for Scala.js` assumes existence of a `bootstrapper`
in every test class - apparently, because test discovery for `JUnit4`
is based on annotations, and reflection on Scala.js is not powerful enough,
so tests are pre-discovered _at compile time_,
and JUnit4-specific bootstrappers generated for them.

On Scala 3, bootstrappers are generated by the `Scala.js` compiler;
on Scala 2, they are not, resulting in:

[source]
----
Error while loading test class org.podval.tools.test.JUnit4ScalaJSTest failed:
java.lang.ClassNotFoundException: Cannot find org.podval.tools.test.JUnit4ScalaJSTest$scalajs$junit$bootstrapper$
  at org.scalajs.junit.JUnitTask.loadBootstrapper(main.js:13275)
  at org.scalajs.junit.JUnitTask.execute(main.js:13365)
----

To get the bootsrappers generated on Scala 2,
a dedicated Scala compiler plugin has to be added: `scalajs-junit-test-plugin`.
This compiler plugin can _only_ be added when `JUnit4 for Scala.js`
is actually on the classpath - or Scala compiler breaks ;)

see:

- https://github.com/scala-js/scala-js/issues/2937
- https://github.com/scala-js/scala-js/commit/269d1aaf1fa20afbcc3940b9dba58e99ee010dc1
- https://github.com/scala-js/scala-js/issues/4191

[#test-detection]
=== Test Detection
Plugin needs to associate a test framework and a fingerprint with each test class,
so it uses its own test detector.

This is why file-name based test scan is not supported
(`isScanForTestClasses` must be at its default value `true`):
name of the test class is not sufficient to determine which test framework
the class belongs to.

This is also why `JUnit5` is not supported:
it insists on discovering the tests itself, as a comment on the `JupiterTestFingerprint.annotationName()` says:

> return The name of this class. This is to ensure that SBT does not find
> any tests so that we can use JUnit Jupiter's test discovery mechanism.

Well, mission accomplished: my test detector does not find any tests either.

Originally, I coded a test detection mechanism that used
analysis file generated by the Scala compiler.
This code was later replaced with a traditional mechanism
based on scanning the class files,
similar to the mechanism used by Gradle for test detection with `JUnit4` and `TestNG`.

If a class file is recognized by more than one framework
(e.g. `MUnit` tests, which are also `JUnit4` tests),
it is attributed to the framework whose fingerprint is closer to
the test class in the hierarchy (e.g. `MUnit`).

If a test class is encountered with more than one framework claiming it
at the same distance in the hierarchy
(which does not happen naturally, but can be constructed),
mistake is assumed, a warning is issued, and the class is ignored.

On `Scala.js`, annotation are not available at runtime
(Scala.js compiler does not add `RuntimeVisibleAnnotations` to the class file),
so this mechanism alone does not detect tests that are marked as such
using annotations.

Currently, the only test framework that marks tests as tests using annotations
is `JUnit4 for Scala.js`.
When `JUnit4 for Scala.js` is on the classpath,
for each test class candidate
plugin looks for the bootstrapper left behind by the Scala.js compiler
(or, on Scala 2, Scala compiler plugin that generates bootstrappers).
Presence of a bootstrapper `TestClass$scalajs$junit$bootstrapper$`
is treated as a presence of the `@Test` annotation on `TestClass`,
which marks it as a test belonging to the `JUnit4 for Scala.js` test framework.

=== Nested Tasks and Test Cases

`sbt` test interface allows test framework to return nested tasks
when executing a task;
of the test frameworks supported by the plugin,
only `ScalaCheck` uses this mechanism:
it returns test cases of the test class being executed
as  nested tasks (with `TestSelector`).

All other frameworks run the test cases directly
and report the results via event handler;
what selector is reported depends on the test framework:

- most test frameworks use `TestSelector`;
- `uTest` uses `NestedTestSelector`;
- `ScalaTest` uses `NestedTestSelector` for test cases from the nested suites;
- `JUnit4`, `JUnit4 for Scala.js` and `MUnit` use `TestSelector`
even for test cases from the nested suites,
but they prepend the name of the class to the test case name
(both in the selector and in the event's `fullyQualifiedName`);
plugin makes sure to attribute test cases to the correct test classes.

=== Gradle Internals
To stop tests from being forked - which is needed to run tests on Scala.js -
I had to fork `org.gradle.api.internal.tasks.testing.detection.DefaultTestExecuter`
(see link:src/main/scala/org/podval/tools/test/task/DefaultTestExecuter.scala[DefaultTestExecuter]).
This is suboptimal, since I now have to track changes to the forked class.
My proposal to expose an extension point that would allow to avoid the fork was rejected:
https://github.com/gradle/gradle/issues/32666[32666],
https://github.com/gradle/gradle/pull/32656[32656];
that made it pretty clear that other modifications to Gradle that would make my code
cleaner would be to, so I did not even bother;
here are examples of resulting ugliness:

- to determine if Gradle is being run by IntelliJ Idea
I had to access non-public classes and methods using reflection
in link:src/main/scala/org/podval/tools/test/task/IntelliJIdea.scala[IntelliJIdea];
- to add to the implementation class path of `WorkerProcessBuilder`,
I had to use reflection in
link:src/main/scala/org/podval/tools/test/task/SbtTestFramework.scala[SbtTestFramework];
- to set test framework on the test task, I had to use reflection
in link:src/main/scala/org/podval/tools/test/task/TestTask.scala[TestTask];
- to set options on the test framework, I copied
`org.gradle.api.tasks.testing.Test.options`: it is private and too short to bother with reflection;
- to call `ForkedTestClasspath.getApplicationClasspath()` I had to use reflection,
since it returns `org.gradle.internal.impldep.com.google.common.collect.ImmutableList`,
which is not accessible from the plugin and results in `java.lang.NoSuchMethodError`;
- since Gradle's internal copy of `org.ow2.asm:asm` is under `impldep` and is not accessible to the plugin, I had to add an explicit dependency on `org.ow2.asm:asm`;
- `org.gradle.api.tasks.testing.Test.testsAreNotFiltered()` calls `Test.noCategoryOrTagOrGroupSpecified()`,
which recognizes only the test frameworks explicitly supported by Gradle (`JUnit` and `TestNG`); since I can not override it, I just use
`org.gradle.api.tasks.testing.junit.JUnitOptions` as `SbtTestFrameworkOptions`.

=== AsciiDoc
GitHub stupidly disables AsciDoc includes in README;
see https://github.com/github/markup/issues/1095[the discussion].

One include (of the `versions.adoc` in `README.adoc`)
is not enough to bother with https://github.com/asciidoctor/asciidoctor-reducer[AsciiDoctor Reducer],
so I just patch the Readme.adoc...

I also write versions to `gradle.properties` and use them in `gradle.build`.

== Credits

I want to thank the maintainers of:

- https://www.scala-js.org/[Scala.js];
- https://github.com/sbt/test-interface[sbt test interface];
- https://github.com/junit-team/junit4[JUnit4];
- sbt test framework https://github.com/sbt/junit-interface[implementation] for JUnit4;
- https://scalameta.org/munit[MUnit];
- https://scalacheck.org[ScalaCheck];
- https://www.scalatest.org[ScalaTest];
- https://etorreborre.github.io/specs2[specs2];
- https://github.com/com-lihaoyi/utest[uTest];
- https://github.com/zio/zio[ZIO Test];

I want to thank:

- https://github.com/maiflai[maiflai] for the
https://github.com/maiflai/gradle-scalatest[ScalaTest Gradle plugin];
- https://github.com/gtache[gtache] for the
https://github.com/gtache/scalajs-gradle[existing Scala.js Gradle plugin];
- https://github.com/srs[srs] for the
https://github.com/srs/gradle-node-plugin[Node.js Gradle Plugin];
- https://stackoverflow.com/users/1149944/gzm0[gzm0] for the
Stack Overflow https://stackoverflow.com/a/65777102/670095[answer]
that was _extremely_ helpful
for understanding how the Scala.js linker should be called;
- https://github.com/zstone1[zstone1] for the encouragement and for
https://github.com/dubinsky/scalajs-gradle/issues/7[requesting]
basic testing functionality;
- https://github.com/machaval[machaval] for the encouragement, for
https://github.com/dubinsky/scalajs-gradle/issues/9[requesting]
support for Scala 2.12
and for helping me understand the https://github.com/dubinsky/scalajs-gradle/issues/16[limits]
of such support;
- https://github.com/qwqawawow[qwqawawow] for a
https://github.com/dubinsky/scalajs-gradle/issues/18[bug report];
- https://github.com/a01fe[a01fe] for a
https://github.com/dubinsky/scalajs-gradle/issues/34[bug report];
- https://github.com/kyri-petrou[kyri-petrou] for helping me fix
ZIO Test's treatment of https://github.com/zio/zio/pull/9680[test wildcards]
and https://github.com/zio/zio/pull/9756[test name matching];
- https://github.com/sjrd[sjrd] for the helpful text
https://www.scala-lang.org/2020/11/03/scalajs-for-scala-3.html[Implementing Scala.JS Support for Scala 3]
and for working with me on fixing issues
with JUnit4 for Scala.js reporting of
https://github.com/scala-js/scala-js/pull/5132[test failure throwable]
and https://github.com/scala-js/scala-js/pull/5134[test duration];
- https://github.com/cheeseng[cheeseng] for helping me understand
the https://github.com/scalatest/scalatest/issues/2357[problem]
with running nested ScalaTest suites using my plugin;
- https://github.com/tgodzik[tgodzik] for accepting my fix for MUnit's
reporting of https://github.com/scalameta/munit/pull/918[test duration];
- https://github.com/etorreborre[etorreborre] for accepting my fix for specs2's
treatment of https://github.com/etorreborre/specs2/pull/1327[test wildcards];
